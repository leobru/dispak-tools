user 419900 ะทั5^
dis 67(77-wr)^
dis 66(2148-440)^
dis 65(2048)^
EEB1A3
*name
*      to perso:670000
*call yesmemory
*      libra:67
*libra:66
*pascal
*trans:newpasc,,670000
(*=s8,p-,t-,u-,y+,k9,l0*)
program pascompl(output, child, pasinput, pasinfor);
%
label 9999;
%
const
%   boilerplate = ' PASCAL COMPILER 15.0 (15.02.82)';
    boilerplate = ' PASCAL BACK TO LIFE (15.08.2017)';
%
    fnSQRT  = 0;  fnSIN  = 1;  fnCOS  = 2;  fnATAN  = 3;  fnASIN = 4;
    fnLN    = 5;  fnEXP  = 6;  fnABSR = 7;  fnTRUNC = 8;  fnODD  = 9;
    fnORD   = 10; fnCHR  = 11; fnSUCC = 12; fnPRED  = 13; fnEOF  = 14;
    fnREF   = 15; fnEOLN = 16; fnSQRR = 17; fnROUND = 18; fnCARD = 19;
    fnMINEL = 20; fnPTR  = 21; fnSHIFT = 22; fnABSI = 23; fnSQRI  = 24;
%
    S3 = 0;
    S4 = 1;
    S5 = 2;
    S6 = 3;
    NoPtrCheck = 4;
    NoStackCheck = 5;
%
    DebugInteractive = 44;
    DebugCode  = 45;
    DebugPrint = 46;
    DebugEntry = 47;
%
    ASN64 = 360100B;
%
    errBooleanNeeded = 0;
    errIdentAlreadyDefined = 2;
    errNoIdent = 3;
    errNotAType = 4;
    errNoConstant = 6;
    errConstOfOtherTypeNeeded = 7;
    errTypeMustNotBeFile = 9;
    errNotDefined = 11;
    errBadSymbol = 12;
    errNeedOtherTypesOfOperands = 21;
    errWrongVarTypeBefore = 22;
    errUsingVarAfterIndexingPackedArray = 28;
    errNoSimpleVarForLoop = 30;
    errTooManyArguments = 38;
    errNoCommaOrParenOrTooFewArgs = 41;
    errNumberTooLarge = 43;
    errVarTooComplex = 48;
    errEOFEncountered = 52;
    errFirstDigitInCharLiteralGreaterThan3 = 60;
%
    macro = 100000000B;
    mcACC2ADDR = 6;
    mcPOP = 4;
    mcPUSH = 5;
    mcMULTI = 7;
    mcADDSTK2REG = 8;
    mcADDACC2REG = 9;
    mcODD = 10;
    mcSQRR = 12;
    mcROUND = 11;
    mcMINEL = 15;
    mcSQRI = 13;
    mcCARD = 23;
    mcSHIFT = 24;
%
    ASCII0 =    4000007B;
    E1 =        4000010B;
    ZERO =      4000011B;
    MULTMASK =  4000012B;
    MANTISSA =  4000014B;
    MINUS1 =    4000017B;
    PLUS1 =     4000021B;
    BITS15 =    4000022B;
    REAL05 =    4000023B;
    ALLONES =   4000024B;
    HEAPPTR =   4000027B;
    
    KATX =      0000000B;
%   KSTX =      0010000B;
    KXTS =      0030000B;
    KADD =      0040000B;
    KSUB =      0050000B;
    KRSUB =     0060000B;
    KAMX =      0070000B;
    KXTA =      0100000B;
    KAAX =      0110000B;
    KAEX =      0120000B;
    KARX =      0130000B;
    KAVX =      0140000B;
    KAOX =      0150000B;
%   KDIV =      0160000B;
    KMUL =      0170000B;
    KAPX =      0200000B;
    KAUX =      0210000B;
    KACX =      0220000B;
    KANX =      0230000B;
    KYTA =      0310000B;
%   KASN =      0360000B;
    KNTR =      0370000B;
    KATI =      0400000B;
%   KSTI =      0410000B;
    KITA =      0420000B;
    KITS =      0430000B;
    KMTJ =      0440000B;
    KJADDM =    0450000B;
    KE74 =      0740000B;
    KUTC =      2200000B;
    CUTC =      2200000C;
    KWTC =      2300000B;
    CWTC =      2300000C;
    KVTM =      2400000B;
    KUTM =      2500000B;
%   KUZA =      2600000B;
%   KU1A =      2700000B;
    KUJ =       3000000B;
    KVJM =      3100000B;
    KVZM =      3400000B;
%   KV1M =      3500000B;
    KVLM =      3700000B;
%
    I7 =        34000000B;      (* frame pointer *)
    I8 =        40000000B;      (* const pointer *)
    I9 =        44000000B;      (* temp register *)
    I10 =       50000000B;      (* temp register *)
    I11 =       54000000B;      (* temp register *)
    I12 =       60000000B;      (* temp register *)
    I13 =       64000000B;      (* link register *)
    I14 =       70000000B;      (* temp register *)
    SP =        74000000B;      (* stack pointer, reg 15 *)
%
type
    symbol = (
(*0B*)  IDENT,      INTCONST,   REALCONST,  CHARCONST,
        LTSY,       GTSY,       NOTSY,      LPAREN,
(*10B*) LBRACK,     MULOP,      ADDOP,      RELOP,
        RPAREN,     RBRACK,     COMMA,      SEMICOLON,
(*20B*) PERIOD,     ARROW,      COLON,      BECOMES,
        LABELSY,    CONSTSY,    TYPESY,     VARSY,
(*30B*) FUNCSY,     PROCSY,     SETSY,      PACKEDSY,
        ARRAYSY,    RECORDSY,   FILESY,     BEGINSY,
(*40B*) IFSY,       CASESY,     REPEATSY,   WHILESY,
        FORSY,      WITHSY,     GOTOSY,     ENDSY,
(*50B*) ELSESY,     UNTILSY,    OFSY,       DOSY,
        TOSY,       DOWNTOSY,   THENSY,     SELECTSY,
(*60B*) PROGRAMSY,  OTHERSY,    NOSY
);
%
idclass = (
        TYPEID,     ENUMID,     ROUTINEID,  VARID,
        FORMALID,   FIELDID
);
%
insn = (
(*000*) ATX,   STX,   OP2,   XTS,   ADD,   SUB,   RSUB,  AMX,
(*010*) XTA,   AAX,   AEX,   ARX,   AVX,   AOX,   ADIVX, AMULX,
(*020*) APX,   AUX,   ACX,   ANX,   EADD,  ESUB,  ASX,   XTR,
(*030*) RTE,   YTA,   OP32,  OP33,  EADDI, ESUBI, ASN,   NTR,
(*040*) ATI,   STI,   ITA,   ITS,   MTJ,   JADDM, ELFUN,
(*047*) UTC,   WTC,   VTM,   UTM,   UZA,   U1A,   UJ,    VJM
);
%
setofsys = set of ident .. selectsy;
%
operator = (
    MUL,        RDIVOP,     AMPERS,     IDIVOP,     IMODOP,
    PLUSOP,     MINUSOP,    OROP,       NEOP,       EQOP,
    LTOP,       GEOP,       GTOP,       LEOP,       INOP,
    IMULOP,     IDIVROP,    SETAND,     SETXOR,     SETOR,
    SETSUB,     INTPLUS,    INTMINUS,   badop27,    badop30,
    badop31,    MKRANGE,    ASSIGNOP,   GETELT,     GETVAR,
    op36,       op37,       GETENUM,    GETFIELD,   DEREF,
    FILEPTR,    op44,       ALNUM,      PCALL,      FCALL,
    BOUNDS,     TOREAL,     NOTOP,      INEGOP,     RNEGOP,
    STANDPROC,  NOOP
);
%
opgen = (
    LOOPLIMIT,  STORE, LOAD,  BINOP,  SETREG,
    gen5,  STOREELT,  gen7,  gen8,  LOADINT,
    PUSHARG, gen11, gen12, FILEACCESS, gen14,
    gen15, PCKUNPCK, LITINSN
);
%
% Flags for ops that can potentially be optimized if one operand is a constant
opflg = (
    opfCOMM, opfHELP, opfAND, opfOR, opfDIV, opfMOD, opfMULMSK, opfASSN, opfINV
);
%
kind = (
    kindReal, kindScalar, kindRange, kindPtr,
    kindSet, kindArray, kindRecord, kindFile,
    kindCases
);
%
bitset = set of 0..47;
%
eptr = @expr;
tptr = @types;
irptr = @identrec;
%
word = record case integer of
    0: (i: integer);
    1: (r: real);
    2: (b: boolean);
    3: (a: alfa);
    7: (c: char);
    8: (cl: idclass);
    13: (m: bitset)
    end;
%
oiptr = @oneinsn;
%
oneinsn  = record
    next: oiptr;
    mode, code, offset: integer;
end;
%
ilmode = (ilCONST, il1, il2, il3);
state = (st0, st1, st2);
%
insnltyp  = record
    next, next2: oiptr;
    typ: tptr;
    regsused: bitset;
    ilm: ilmode;
    ilf5: word;
    ilf6: integer;
    ilf7: integer;
    st: state;
    width, shift: integer
end;
%
types = record
    size,
    bits:   integer;
    k:      kind;
    case kind of
    kindReal:   ();
    kindRange:  (base:      tptr;
                 checker,
                 left,
                 right:     integer);
    kindArray:  (abase,
                 range:     tptr;
                 pck:       boolean;
                 perword,
                 pcksize:   integer);
    kindScalar: (enums:     irptr;
                 numen,
                 start:     integer);
    kindSet,
    kindPtr:    (sbase:      tptr);
    kindFile:   (fbase:      tptr;
                 elsize:    integer);
    kindRecord: (ptr1,
                 ptr2:      irptr;
                 flag,
                 pckrec:    boolean);
    kindCases:  (sel:       word;
                 first,
                 next:      tptr;
                 r6:        tptr)
    end;
%
typechain = record
    next:         @typechain;
    type1, type2: tptr;
end;

charmap   = packed array ['_000'..'_176'] of char;
textmap   = packed array ['_052'..'_177'] of '_000'..'_077';
%
four = array [1..4] of integer;
entries   = array [1..42] of bitset;
%
expr = record
    case operator of (* arbitrary so far *)
    NOOP:       (val:    word;
                 op:     operator;
                 d1, d2: word);
    MUL:        (typ:    tptr;
                 d3:     word;
                 expr1, expr2: eptr);
    BOUNDS:     (d4, d5: word;
                 typ1, typ2: tptr);
    NOTOP:      (d6, d7: word;
                 id1, id2: irptr);
    STANDPROC:  (d8, d9: word;
                 num1, num2: integer);
end;
%
kword = record
    w:      word;
    sym:    symbol;
    op:     operator;
    next:   @kword;
end;
%
strLabel = record
    next:       @strLabel;
    ident:      word;
    offset:     integer;
    exitTarget: integer;
end;
%
numLabel = record
    id:         word;
    line:       integer;
    frame:      integer;
    offset:     integer;
    next:       @numLabel;
    defined:    boolean;
end;
%
identrec = record
    id:     word;
    offset: integer;
    next:   irptr;
    typ: tptr;
    cl: idclass;
    case idclass of
    TYPEID,
    VARID:  ();
    ENUMID,
    FORMALID:
            (list: irptr; value: integer);
    FIELDID:
            (maybeUnused: integer;
             uptype: tptr;
             pckfield:  boolean;
             shift:     integer;
             width:     integer);
    ROUTINEID:
            (low: integer;
             high: word;
             argList, preDefLink: irptr;
             level, pos: integer;
             flags: bitset
            );
end;
extfilerec = record
    id:     word;
    offset: integer;
    next:   @extfilerec;
    location,
    line: integer
end;
numberSuffix = (noSuffix, suffixB, suffixT, suffixC);
%
var (* total size 4791 words *)
%
(*40*)      suffix: numberSuffix;
(*41-46*)   bigSkipSet, statEndSys, blockBegSys, statBegSys,
            skipToSet, lvalOpSet: setofsys;
(*47-49*)   bool47z, bool48z, bool49z: boolean;
(*50*)      dataCheck: boolean;
(*51*)      jumpType: integer;
(*52*)      jumpTarget: integer;
(*53*)      int53z: integer;
(*54*)      charClass: operator;
(*55-56*)   SY, prevSY: symbol;
(*57*)      savedObjIdx: integer;
(*58*)      FcstCnt: integer;
(*59*)      symTabPos: integer;
(*60*)      entryPtCnt: integer;
(*61*)      fileBufSize: integer;
(*62-63*)   expr62z, expr63z: eptr;
(*64*)      curInsnTemplate: integer;
(*65*)      maxLineLen: integer;
(*66*)      linePos: integer;
(*67*)      prevErrPos: integer;
(*68*)      errsInLine: integer;
(*69*)      moduleOffset: integer;
(*70*)      lineStartOffset: integer;
(*71*)      curFrameRegTemplate: integer;
(*72*)      curProcNesting: integer;
(*73*)      totalErrors: integer;
(*74*)      lineCnt: integer;
(*75*)      bucket: integer;
(*76*)      strLen: integer;
(*77*)      heapCallsCnt: integer;
(*78*)      heapSize: integer;
(*79*)      arithMode: integer;
(*80*)      stmtName: alfa;
(*81*)      keywordHashPtr: @kword;
(*82*)      curVarKind: kind;
(*83*)      curExternFile: @extfilerec;
(*84*)      commentModeCH: char;
(*85*)      besmInsn: word;
(*86*)      CH: char;
(*87*)      prevInsn: word;
(*88*)      debugLine: integer;
(*89*)      lineNesting: integer;
(*90*)      FcstTop, FcstBottom: integer;
(*91*)      objBufIdx: integer;
(*92-94*)   int92z, int93z, int94z: integer;
(*95*)      prevOpcode: integer;
(*96*)      charEncoding: integer;
(*97*)      int97z: integer;
(*98*)      atEOL: boolean;
(*99*)      checkTypes: boolean;
(*100-102*) isDefined, putLeft, fetch: boolean;
(*103*)     errors: boolean;
(*104*)     declExternal: boolean;
(*105*)     rangeMismatch: boolean;
(*106*)     doPMD: boolean;
(*107*)     checkBounds: boolean;
(*108*)     fuzzReals: boolean;
(*109*)     fixMult: boolean;
(*110*)     bool110z: boolean;
(*111*)     pseudoZ: boolean;
(*112*)     allowCompat: boolean;
(*113*)     checkFortran: boolean;
(*114*)     outputFile: irptr;
(*115*)     inputFile: irptr;
(*116*)     programObj: irptr;
(*117*)     hashTravPtr: irptr;
(*118*)     uProcPtr: irptr;
(*119*)     externFileList: @extfilerec;
(*120-121*) typ120z, typ121z: tptr;
(*122*)     pointerType: tptr;
(*123*)     setType: tptr;
(*124*)     booleanType: tptr;
(*125*)     textType: tptr;
(*126*)     integerType: tptr;
(*127*)     realType: tptr;
(*128*)     charType: tptr;
(*129*)     alfaType: tptr;
(*130*)     arg1Type: tptr;
(*131*)     arg2Type: tptr;
(*132*)     numLabList: @numLabel;
(*133*)     chain: @typechain;
(*134*)     curToken: word;
(*135*)     curVal: word;
(*136*)     O77777: bitset;
(*137*)     intZero: bitset;
(*138-139*) unused138z, extSymMask: bitset;
(*140*)     halfWord: bitset;
(*141*)     leftInsn: bitset;
(*142*)     hashMask: word;
(*143*)     curIdent: word;
(*144-148*) toAlloc, set145z, set146z, set147z, set148z: bitset;
(*149*)     optSflags: word;
(*150*)     litOct: word;
(*151*)     litExternal: word;
(*152*)     litForward: word;
(*153*)     litFortran: word;
(*154*)     uVarPtr: eptr;
(*155*)     curExpr: eptr;
(*156*)     insnList: @insnltyp;
(*157-158*) fileForOutput, fileForInput: @extfilerec;
(*159*)     maxSmallString: integer;
(*160*)     extSymAdornment: integer;
(*161-165*) smallStringType: array [2..6] of tptr;
(*166*)     symTabCnt: integer;
(*167-246*) symtabarray: array [1..80] of word;
(*247-326*) symtbidx: array [1..80] of integer;
(*327-331*) iMulOpMap: array [MUL..IMODOP] of operator;
(*332-338*) setOpMap: array [MUL..MINUSOP] of operator;
(*339-340*) iAddOpMap: array [PLUSOP..MINUSOP] of operator;
(*341-369*) entryPtTable: entries;
(*370-397*) frameRestore: array [3..6] of four;
(*398-413*) indexreg: array [1..15] of integer;
(*414-450*) opToInsn: array [MUL..op44] of integer;
(*451-487*) opToMode: array [MUL..op44] of integer;
(*488-524*) opFlags: array [MUL..op44] of opflg;
(*525-548*) funcInsn: array [0..24] of integer;
(*549-595*) insnTemp: array [insn] of integer;
(*596*)     frameRegTemplate: integer;
(*597*)     constRegTemplate: integer;
(*598*)     disNormTemplate: integer;
(*599-728*) lineBufBase: array [1..130] of char;
(*729*)     errMapBase: array [0..9] of integer;
(*739*)     chrClassTabBase: array ['_000'..'_177'] of operator;
(*867*)     kwordHashTabBase: array [0..127] of @kword;
(*995*)     charSymTabBase: array ['_000'..'_177'] of symbol;
(*1123*)    symHashTabBase: array [0..127] of irptr;
(*1251*)    typeHashTabBase: array [0..127] of irptr;
(*1378*)    helperMap: array [1..99] of integer;
(*1477*)    helperNames: array [1..99] of bitset;
(*1577-
  2409*)    symTab: array [74000B..75500B] of bitset;
(*2410*)    systemProcNames: array [0..29] of integer;
(*2440*)    resWordNameBase: array [0..29] of integer;
(*2470*)    longSymCnt: integer;
(*2471*)    longSymTabBase: array [1..90] of integer;
(*2560*)    longSyms: array [1..90] of bitset;
(*2651*)    constVals: array [1..500] of alfa;
(*3151*)    constNums: array [1..500] of integer;
(*3651*)    objBuffer: array [1..1024] of bitset;
(*4675*)    iso2text: array ['_052'..'_177'] of '_000'..'_077';
(*4761*)    fcst: file of bitset; (* last *)
%
    pasinput: text;
%
    child: file of bitset;
%
    pasinfor: record
        (*0*) listMode:     integer;
        (*1*) errors:       @boolean;
        (*2*) entryptr:     @entries;
        (*3*) startOffset:  integer;
      (*4-6*) a0, a1, a4:   @charmap;
        (*7*) a3:           @textmap;
     (*8-17*) sizes:        array [1..10] of @integer;
       (*18*) flags:        bitset;
        end;
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%              PROGRAMME                 %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure programme(var l2arg1z: integer; procPtr: irptr);
label 22420, 22421, 23301;
var
    preDefHead, typelist, scopeBound, l2var4z, curIdRec, workidr: irptr;
    isPredefined, l2bool8z, inTypeDef: boolean;
    l2var10z: eptr;
    fInitOff: integer;
    l2var12z: word;
    curType, l2typ14z: tptr;
    l2var15z, l2var16z: @numLabel;
    strLabList: @strLabel;
%
    l2int18z, ii, curVarOff, l2int21z, temp: integer;
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%              PrintErrMsg               %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure printErrMsg(errno: integer);
type
    errtxt = packed array [0..100] of '_000'..'_077';
var
    errptr: @errtxt;
    errtext: array [0..100] of '_000'..'_077';
    i: integer;
    c: char;
%
    function pasmitxt(errno: integer): @errtxt;
        fortran;
%
    function pasisoxt(txtchar: '_000'..'_077'): char;
        fortran;
%
_( (* PrintErrMsg *)
    write(' ');
    if errno >= 200 then
        write('system=', errno:0)
    else _(
        if (errno > 88) then
            printErrMsg(86)
        else if errno in [16..18, 20] then _(
            if errno = 20 then
                errno := ord(sy = ident)*2 + 1
            else
                write(curToken.i:0,' ');
        _);
        errptr := pasmitxt(errno);
        unpack(errptr@, errtext, 0);
(loop)  for i:=0 to 100 do _(
            c := pasisoxt(errtext[i]);
            if c = '*' then
                exit loop;
            write(c);
        _);
        write(' ');
        if errno in [17, 22] then
            if errno = 17 then
                write(int97z:0)
            else
                write(stmtName);
    _);
    if errno <> 86 then
        writeln;
_); (* PrintErrMsg *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%              printTextWord             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure printTextWord(val: word);
%
    procedure PASTPR(val: word);
        external;
%
_( (* printTextWord *)
    write(' ');
    PASTPR(val)
_); (* printTextWord *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%              makeStringType                %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure makeStringType(var res: tptr);
var span: tptr;
_(
    if maxSmallString >= strLen then
        res := smallStringType[strLen]
    else _(
        new(span = 7);
        new(res, kindArray);
        with span@ do _(
            size := 1;
            checker := 0;
            bits := 12;
            k := kindRange;
            base := integerType;
            left := 1;
            right := strLen;
        _);
        with res@ do _(
            size := (strLen + 5) div 6;
            if size = 1 then
                bits := strLen * 8
            else
                bits := 0;
            k := kindArray;
            base := charType;
            range := span;
            pck := true;
            perword := 6;
            pcksize := 8;
        _)
    _)
_); (* makeStringType *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%              addToHashTab              %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure addToHashTab(arg: irptr);
_(
    curVal.m := arg@.id.m * hashMask.m;
    mapai(curval.a, curval.i);
    arg@.next := symHashTabBase[curval.i];
    symHashTabBase[curval.i] := arg;
_); (* addToHashTab *)
%
procedure error(errno: integer);
    forward;
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%              storeObjWord              %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure storeObjWord(insn: bitset);
_(
    objBuffer[objBufIdx] := insn;
    moduleOffset := moduleOffset + 1;
    if objBufIdx = 1024 then _(
        error(49); (* errTooManyInsnsInBlock *)
        objBufIdx := 1
    _) else
        objBufIdx := objBufIdx + 1;
_); (* storeObjWord *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%              form1Insn                 %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure form1Insn(arg: integer);
var
    insn, opcode: word;
    half1, half2: bitset;
    pos: integer;
_(
    insn.i := arg;
    opcode.m := insn.m * [0, 1, 3, 24..32];
    if opcode.i = insnTemp[UJ] then _(
        if prevOpcode = opcode.i then
            exit;
        if putLeft and (prevOpcode = 1) then _(
            pos := objBufIdx - 1;
            if objBuffer[pos] * [0..8] = [0, 1, 3..5, 8] then _(
                prevOpcode := opcode.i;
                half1 := insn.m * [33..47];
                besm(ASN64-24);
                half1 :=;
                half2 := objBuffer[pos] * [9..23];
                besm(ASN64+24);
                half2 :=;
                objBuffer[pos] := [0, 1, 3, 4, 6, 28, 29] +
                    half1 + half2;
                exit;
            _)
        _)
    _) else if (prevOpcode <> -1) and (insn.i mod 4096 <> 0) and
    (insn.m mod prevInsn.m = [32]) (* maybe ATX/XTA *) then _(
% Load after store; if the load reg/off is the same as the store,
% and the store was not a stack push, there is no need to so the read.
          if (prevInsn.i <> 74000000B (* not 15,ATX, *)) and
             (prevInsn.m * [28, 30..35] = [] (* but still ATX *)) then
             exit (* skip the XTA *)
    _);
    prevOpcode := opcode.i;
    prevInsn := insn;
    if (putLeft) then _(
        leftInsn := insn.m * halfWord;
        besm(ASN64-24);
        leftInsn :=;
        putLeft := false
    _) else _(
        putLeft := true;
        storeObjWord(leftInsn + (insn.m * halfWord))
    _)
_); (* form1Insn *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure form2Insn(i1, i2: integer);
_(
    form1Insn(i1);
    form1Insn(i2);
_); (* form2Insn *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure form3Insn(i1, i2, i3: integer);
_(
    form2Insn(i1, i2);
    form1Insn(i3);
_); (* form3Insn *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure disableNorm;
_(
    if arithMode <> 1 then _(
        form1Insn(disNormTemplate);
        arithMode := 1;
    _)
_); (* disableNorm *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function getObjBufIdxPlus: integer;
_(
   if putLeft then
       getObjBufIdxPlus := objBufIdx + 4096
   else
       getObjBufIdxPlus := objBufIdx
_); (* getObjBufIdxPlus *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure formJump(var arg: integer);
var
    pos: integer;
    isLeft: boolean;
_(
    if prevOpcode <> insnTemp[UJ] then _(
        pos := getObjBufIdxPlus;
        isLeft := putLeft;
        form1Insn(jumpType + arg);
        if putLeft = isLeft then
            pos := pos - 1;
        arg := pos;
    _)
_); (* formJump *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure padToLeft;
_(
    if not putLeft then
        form1Insn(insnTemp[UTC]);
    prevOpcode := -1;
_); (* padToLeft *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure formAndAlign(arg: integer);
_(
    form1Insn(arg);
    padToLeft;
    prevOpcode := 1;
_); (* formAndAlign *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure putToSymTab(arg: bitset);
_(
    symTab[symTabPos] := arg;
    if symTabPos = 75500B then _(
        error(50); (* errSymbolTableOverflow *)
        symTabPos := 74000B;
    _) else
        symTabPos := symTabPos + 1;
_); (* putToSymTab *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function allocExtSymbol(l3arg1z: bitset): integer;
var
    l3var1z: word;
    l3var2z: integer;
_(
    allocExtSymbol := symTabPos;
    if (curVal.m * halfWord <> []) then _(
        for l3var2z to longSymCnt do
            if (curVal.m = longSyms[l3var2z]) then _(
                allocExtSymbol := longSymTabBase[l3var2z];
                exit
            _);
        longSymCnt := longSymCnt + 1;
        if (longSymCnt >= 90) then _(
            error(51); (* errLongSymbolOverflow *)
            longSymCnt := 1;
        _);
        longSymTabBase[longSymCnt] := symTabPos;
        longSyms[longSymCnt] := curVal.m;
        l3arg1z := l3arg1z + [25];
    _) else
        l3arg1z := l3arg1z + curVal.m;
    putToSymTab(l3arg1z);
_); (* allocExtSymbol *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function getHelperProc(l3arg1z: integer): integer;
_(
    if (helperMap[l3arg1z] = 0) then _(
        curVal.m := helperNames[l3arg1z];
        helperMap[l3arg1z] := allocExtSymbol(extSymMask);
    _);
    getHelperProc := helperMap[l3arg1z] + (KVJM+I13);
_); (*getHelperProc *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure toFCST;
_(
    write(FCST, curVal.m);
    FcstCnt := FcstCnt + 1;
_); (* toFCST *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Modified: sorting constants with bit48=1 and bit48=0
% separately avoids replications due to non-transitive ALFA comparisons
% (saves about 100B words of code)
function addCurValToFCST: integer;
var
    low, high, mid: integer;
    bit48:boolean;
_(
    bit48 := [0] <= curVal.m;
    if bit48 and (FcstTop = 501)  
    or not bit48 and (FcstBottom = 0) then _(
        addCurValToFCST := FcstCnt;
        if bit48 then _( FcstTop := 500;  mid := ; _)
        else _( FcstBottom := 1; mid := ; _);
        constVals[mid] := curVal.a;
        constNums[mid] := FcstCnt;
    _) else _(
        if bit48 then _( low := FcstTop; high := 500 _)
        else _( low := 1; high := FcstBottom _);
        repeat
            mid := (low + high) div 2;
            if (curVal.a = constVals[mid]) then _(
                addCurValToFCST := constNums[mid];
                exit
            _);
            if curval.a < constVals[mid] then
                high := mid - 1
            else
                low := mid + 1
        until high < low;
        addCurValToFCST := FcstCnt;
        if FcstTop - FcstBottom > 1 then _(
            if curval.a < constVals[mid] then
                high := mid - ord(bit48)
            else
                high := mid + ord(not bit48);
            if bit48 then _(
                for mid := FcstTop to high do _(
                    low := mid - 1;
                    constVals[low] := constVals[mid];
                    constNums[low] := constNums[mid];
                _);
                FcstTop := FcstTop - 1;
            _) else _(
                for mid := FcstBottom downto high do _(
                    low := mid + 1;
                    constVals[low] := constVals[mid];
                    constNums[low] := constNums[mid];
                _);
                FcstBottom := FcstBottom + 1;
            _);
            constVals[high] := curVal.a;
            constNums[high] := FcstCnt;
        _);
    _);
    toFCST;
_); (* addCurValToFCST *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function allocSymtab(l3arg1z: bitset): integer;
var
    low, high, mid: integer;
    value: word;
_(
    low := 1;
    value.m := l3arg1z;
    if symTabCnt = 0 then _(
        allocSymtab := symTabPos;
        symTabCnt := 1;
        symTabArray[1].m := l3arg1z;
        symtbidx[1] := symTabPos;
    _) else _(
        high := symTabCnt;
        repeat
            mid := (low + high) div 2;
            if (value = symTabArray[mid]) then _(
                allocSymtab := symtbidx[mid];
                exit
            _);
            if  value.a < symTabArray[mid].a then
                 high := mid - 1
            else
                 low := mid + 1;
        until high < low;
        allocSymtab := symTabPos;
        if symTabCnt <> 80 then _(
            if value.a < symTabArray[mid].a then
                high := mid
            else
                high := mid + 1;
            for mid := symTabCnt downto high do _(
                low := mid + 1;
                symTabArray[low] := symTabArray[mid];
                symtbidx[low] := symtbidx[mid];
            _);
            symTabCnt := symTabCnt + 1;
            symTabArray[high] := value;
            symtbidx[high] := symTabPos;
        _)
    _);
    putToSymTab(value.m);
_); (* allocSymtab *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function getFCSToffset: integer;
var
    offset: word;
_(
    getFCSToffset := addCurValToFCST;
    offset :=;
    if (offset.i < 2048) then _(
        (* empty *)
    _) else if (offset.i >= 4096) then
        error(204)
    else _(
        getFCSToffset := allocSymtab(offset.m + [24]) - 70000B;
        exit
    _)
_); (* getFCSToffset *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function nrOfBits(value: integer): integer;
_(
    curVal.i := value;
    curVal.m := curVal.m * [7..47];
    nrOfBits := 48-minel(curval.m);
_); (* nrOfBits *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure defineRange(var res: tptr; l, r: integer);
var
    temp: tptr;
    dummyloc: word;
_(
    new(temp=7);
    with temp@ do _(
        size := 1;
        bits := 48;
        base := res;
        checker := 0;
        k := kindRange;
        curVal.i := l;
        curVal.m := curVal.m + intZero;
        left := curVal.i;
        curVal.i := r;
        curVal.m := curVal.m + intZero;
        right := curVal.i;
        if (left >= 0) then
            bits := nrOfBits(curVal.i);
        res := temp
    _)
_); (* defineRange *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function getValueOrAllocSymtab(value: integer): integer;
_(
    curVal.i := value;
    curVal.i := curVal.i MOD 32768;
    if (40000B >= curVal.i) then
        getValueOrAllocSymtab := curVal.i
    else
        getValueOrAllocSymtab :=
            allocSymtab((curVal.m + [24]) * halfWord);
_); (* getValueOrAllocSymtab *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure P0715(mode, arg: integer);
label 1;
var
    addr, insn, leftHalf: bitset;
    isLarge: boolean;
    work, offset: integer;
_(
    if mode = 0 then _(
        padToLeft;
        curVal.i := moduleOffset;
1:      addr := curval.m * [33..47];
        curVal := curVal;
        besm(ASN64-24);
        leftHalf:=;
        while arg <> 0 do _(
            if 4096 < arg then _(
                isLarge := true;
                arg := arg - 4096;
            _) else isLarge := false;
            insn := objBuffer[arg];
            if isLarge then _(
                curVal.m := insn * [9..23];
                besm(ASN64+24);
                curVal :=;
                curVal.m := curVal.m + intZero;
                insn := insn * [0..8, 24..47] + leftHalf;
            _) else _(
                curVal.m := intZero + insn * [33..47];
                insn := insn * [0..32] + addr;
            _);
            objBuffer[arg] := insn;
            arg := curVal.i;
        _);
        exit;
    _) else if mode = 2 then _(
        form1Insn(KVTM+I14 + curVal.i);
        if curVal.i = 74001B then
            form1Insn(KUTM+I14 + FcstCnt);
        form3Insn(KITA+14, insnTemp[ASN] + arg, KAOX+I7+1);
        form1Insn(KATX+I7+1);
        exit;
    _) else if (mode = 1) or (mode < -2) then _(
        arg := arg - curVal.i;
        offset := getFCSToffset;
        if mode = 1 then
            work := getHelperProc(68) + (-64200000B) (* P/DA *)
        else
            work := -mode;
        curVal.i := arg;
        arg := getFCSToffset;
        form3Insn(KATX+SP+1, KSUB+I8 + offset, work);
        form3Insn(KRSUB+I8 + arg, work, KXTA+SP+1);
        exit;
    _) else if mode = -1 then _(
        form1Insn(KVTM+I14 + lineCnt);
        formAndAlign(getHelperProc(arg));
        exit;
    _);
    curVal.i := mode;
    goto 1;
_); (* P0715 *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure endOfLine;
var
    unused: array [1..14] of integer;
    err, errPos, prevPos, listMode,
    startPos, lastErr: integer;
%
    procedure OBPROG(var start, fin: bitset);
        external;
_(
    listMode := pasinfor.listMode;
    if (listMode <> 0) or (errsInLine <> 0) then
    _(
        write(' ', (lineStartOffset + PASINFOR.startOffset):5 oct,
              lineCnt:5, lineNesting:3, commentModeCH);
        startPos := 13;
        if (S4 in optSflags.m)
            and (maxLineLen = 72)
            and (linePos >= 80)
        then _(
            for err := 73 to 80 do
                write(lineBufBase[err]);
            write(' ');
            linePos := 73;
            startPos := 22;
        _); (* 1106 *)
        repeat
            linePos := linePos-1
        until (lineBufBase[linePos]  <> ' ') or (linePos = 0);
        for err to linePos do _(
            output@ := lineBufBase[err];
            put(output);
        _);
        writeln;
        if errsInLine <> 0 then _(
            write('*****':startPos, ' ':errMapBase[0], '0');
            lastErr := errsInLine - 1;
            for err to lastErr do _(
                errPos := errMapBase[err];
                prevPos := errMapBase[err-1];
                if errPos <> prevPos then _(
                    if prevPos + 1 <> errPos then
                        write(' ':(errPos-prevPos-1));
                    write(chr(err + 48));
                _)
            _);
            writeln;
            errsInLine := 0;
            prevErrPos := 0;
        _)
    _); (* 1160 *)
    if (listMode = 2) and (moduleOffset <> lineStartOffset) then _(
        OBPROG(objBuffer[objBufIdx - moduleOffset + lineStartOffset],
               objBuffer[objBufIdx-1]);
    _); (* 1174 *)
    lineStartOffset := moduleOffset;
    linePos := 0;
    lineCnt := lineCnt + 1;
    if eof(pasinput) then _(
        error(errEOFEncountered);
        goto 9999;
    _)
_); (* endOfLine *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure requiredSymErr(sym: symbol);
_(
    if linePos <> prevErrPos then
        error(ord(sym) + 88);
_); (* requiredSymErr *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure readToPos80;
_(
    while linePos < 81 do _(
        linePos := linePos + 1;
        lineBufBase[linePos] := PASINPUT@;
        if linePos <> 81 then get(PASINPUT);
    _);
    endOfLine
_); (* readToPos80 *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure inSymbol;
label
    1473, 1, 2, 2175, 2233, 2320;
var
    localBuf: array [0..130] of char;
    tokenLen, tokenIdx: integer;
    expSign: boolean;
    l3var135z: irptr;
    expMultiple, expValue: real;
    curChar: char;
    numstr: array [1..16] of word;
    l3vars2: array [155..159] of word;
    expLiteral, expMagnitude: integer;
    l3int162z: integer;
    chord: integer;
    l3var164z: integer;
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure nextCH;
_(
    repeat
        atEOL := eoln(PASINPUT);
        CH := PASINPUT@;
        get(PASINPUT);
        linePos := linePos + 1;
        lineBufBase[linePos] := CH;
    until (maxLineLen >= linePos) or atEOL;
_); (* nextCH *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure parseComment;
var
    badOpt, flag: boolean;
    c: char;
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure readOptVal(var res: integer; limit: integer);
_(
    nextCH;
    res := 0;
    while ('9' >= CH) and (CH >= '0') do _(
        res := 10 * res + ord(CH) - ord('0');
        nextCH;
        badOpt := false;
    _);
    if limit < res then badOpt := true;
_); (* readOptVal *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure readOptFlag(var res: boolean);
_(
    nextCH;
    if (CH = '-') or (CH = '+') then _(
        res := CH = '+';
        badOpt := false;
    _);
    nextCH
_); (* readOptFlag *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
_( (* parseComment *)
    nextCH;
    if CH = '=' then _(
        repeat nextCH;
        badOpt := true;
        case CH of
        'D': _(
            readOptVal(curVal.i, 15);
            optSflags.m := optSflags.m * [0..40] + curVal.m * [41..47];
        _);
        'Y': readOptFlag(allowCompat);
        'E': readOptFlag(declExternal);
        'U': _(
            readOptFlag(flag);
            if flag then maxLineLen := 72 else maxLineLen := 120;
        _);
        'S': _(
            readOptVal(curVal.i, 9);
            if curVal.i = 3 then lineCnt := 1
            else if curVal.i in [4..9] then
                optSflags.m := optSflags.m + [curVal.i - 3]
            else
                extSymAdornment := curVal.i;            
        _);
        'F': readOptFlag(checkFortran);
        'L': readOptVal(PASINFOR.listMode, 3);
        'P': readOptFlag(doPMD);
        'T': readOptFlag(checkBounds);
        'A': readOptVal(charEncoding, 4);
        'C': readOptFlag(checkTypes);
        'R': readOptFlag(fuzzReals);
        'M': readOptFlag(fixMult);
        'B': readOptVal(fileBufSize, 4);
        'K': readOptVal(heapSize, 23);
        'Z': readOptFlag(pseudoZ);
        end;
        if badOpt then
            error(54); (* errErrorInPseudoComment *)
        until CH <> ',';
    _); (* 1446 *)
    repeat
        while CH <> '*' do _(
            c := commentModeCH;
            commentModeCH := '*';
            if atEOL then
                endOfLine;
            nextCH;
            commentModeCH := c;
        _);
        nextCH
    until CH = ')';
    nextCH;
_); (* parseComment *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
_(
(again) _( (* inSymbol *)
        if dataCheck then _(
            error(errEOFEncountered);
            readToPos80;
            goto 9999;
        _);
1473:
        while (CH = ' ') and not atEOL do
            nextCH;
        if '_200' < CH then _(
            lineBufBase[linePos] := ' ';
            chord := ord(CH);
            for temp := 130 to chord do _(
                linePos := linePos + 1;
                lineBufBase[linePos] := ' ';
            _);
            nextCH;
            goto 1473;
        _);
        if atEOL then _(
            endOfLine;
            nextCH;
            if CH = '%' then while not atEOL do
                nextCH;
            goto 1473;
        _);
        hashTravPtr := NIL;
        SY := charSymTabBase[CH];
        charClass := chrClassTabBase[CH];
(lexer)
        if SY <> NOSY then _(
            case SY of
            IDENT: _(
1:              curToken.m := [];
                tokenLen := 1;
                repeat
                    curVal.c := iso2text[CH];
                    nextCH;
                    if 8 >= tokenLen then _(
                        tokenLen := tokenLen + 1;
                        curToken := curToken;
                        besm(ASN64-6);
                        curToken:=;
                        curToken.m := curToken.m + curVal.m;
                    _);
                until chrClassTabBase[CH] <> ALNUM;
                curVal.m := curToken.m * hashMask.m;
                mapAI(curVal.a, bucket);
                curIdent := curToken;
                keywordHashPtr := kwordHashTabBase[bucket];
                while keywordHashPtr <> NIL do _(
                    if keywordHashPtr@.w = curToken then _(
                        SY := keywordHashPtr@.sym;
                        charClass := keywordHashPtr@.op;
                        exit lexer;
                    _);
                    keywordHashPtr := keywordHashPtr@.next;
                _);
                isDefined := false;
                SY := IDENT;
                case int93z of
                0: _(
                    hashTravPtr := symHashTabBase[bucket];
                    while hashTravPtr <> NIL do _(
                        if hashTravPtr@.offset = curFrameRegTemplate then
                        _(
                            if hashTravPtr@.id <> curIdent then
                                hashTravPtr := hashTravPtr@.next
                            else _(
                                isDefined := true;
                                exit lexer;
                            _)
                        _) else
                            exit lexer;
                    _);
                _);
                1: _(
2:                  hashTravPtr := symHashTabBase[bucket];
                    while hashTravPtr <> NIL do _(
                        if hashTravPtr@.id <> curIdent then
                            hashTravPtr := hashTravPtr@.next
                        else
                            exit lexer;
                    _);
                _);
                2: (q) _(
                    if expr63z = NIL then
                        goto 2;
                    expr62z := expr63z;
                    l3var135z := typeHashTabBase[bucket];
                    if l3var135z <> NIL then _(
                        while expr62z <> NIL do _(
                            l3int162z := expr62z@.typ2@.size;
                            hashTravPtr := l3var135z;
                            while hashTravPtr <> NIL do _(
                                if (hashTravPtr@.id = curIdent)
                                and (hashTravPtr@.value = l3int162z) then
                                    exit lexer;
                                hashTravPtr := hashTravPtr@.next;
                            _);
                            expr62z := expr62z@.expr1;
                        _);
                    _);
                    goto 2; 
                _);
                3: _(
                    hashTravPtr := typeHashTabBase[bucket];
                    while hashTravPtr <> NIL do _(
                        with hashTravPtr@ do _(
                            if (id = curIdent) and
                               (typ121z = uptype)
                            then
                                exit lexer;
                            hashTravPtr := next;
                       _)
                   _)
                _);
                end;
            _); (* IDENT *)
            REALCONST: _(
                nextCH;
                if charSymTabBase[CH] = IDENT then
                    goto 1;
                if CH = '(' then
                    SY := BEGINSY
                else if CH = ')' then
                    SY := ENDSY
                else _(
                    SY := NOSY;
                    exit
                _);
                nextCH;
            _); (* REALCONST *)
            INTCONST: _( (*=m-*)
                SY := INTCONST;
                tokenLen := 0;
                repeat
                    tokenLen := tokenLen + 1;
                    if (16 >= tokenLen) then
                        numstr[tokenLen].i := ord(CH)-ord('0')
                    else _(
                        error(55); (* errMoreThan16DigitsInNumber *)
                        tokenLen := 1;
                    _);
                    nextCH;
                until charSymTabBase[CH] <> INTCONST;
(octdec)        _(
                    if CH = 'B' then
                        suffix := suffixB
                    else if CH = 'C' then
                        suffix := suffixC
                    else if CH = 'T' then
                        suffix := suffixT
                    else _(
                        suffix := noSuffix;
                        exit octdec;
                    _);
                    nextCH;
                    curToken.c := chr(0);
                    for tokenIdx to tokenLen do _(
                        if 7 < numstr[tokenIdx].i then
                            error(20); (* errDigitGreaterThan7 *)
                        curToken := curToken;
                        besm(ASN64-3);
                        curToken:=;
                        curToken.m := numstr[tokenIdx].m * [45..47] +
                        curToken.m;
                    _);
                    if suffix = suffixB then _(
                        if curToken.m * [0..6] <> [] then _(
                            error(errNumberTooLarge);
                            curToken.i := 1;
                        _) else
                            curToken.m := curToken.m + intZero;
                    _) else if suffix = suffixT then _(
                        l3var164z := 16 - tokenLen;
                        for expMagnitude to l3var164z do _(
                            curToken := curToken;
                            besm(ASN64-3);
                            curToken :=;
                        _);
                    _);
                    exit lexer;
                _); (* octdec *)
                curToken.i := 0;
                for tokenIdx to tokenLen do _(
                    if 109951162777 >= curToken.i then
                        curToken.i := 10 * curToken.i +
                            numstr[tokenIdx].i
                    else _(
                        error(errNumberTooLarge);
                        curToken.i := 1;
                    _);
                _);
                expMagnitude := 0;
                if CH = '.' then _(
                    nextCH;
                    if CH = '.' then _(
                        CH := ':';
                        exit lexer
                    _);
                    curToken.r := curToken.i;
                    SY := REALCONST;
                    if charSymTabBase[CH] <> INTCONST then
                        error(56) (* errNeedMantissaAfterDecimal *)
                    else
                        repeat
                            curToken.r := 10.0*curToken.r + ord(CH)-48;
                            expMagnitude := expMagnitude-1;
                            nextCH;
                        until charSymTabBase[CH] <> INTCONST;
                _); (*2062*)
                if CH = 'E' then _(
                    if expMagnitude = 0 then _(
                        curToken.r := curToken.i;
                        SY := REALCONST;
                    _);
                    expSign := false;
                    nextCH;
                    if CH = '+' then
                        nextCH
                    else if CH = '-' then _(
                        expSign := true;
                        nextCH
                    _);
                    expLiteral := 0;
                    if charSymTabBase[CH] <> INTCONST then
                        error(57) (* errNeedExponentAfterE *)
                    else
                        repeat
                            expLiteral := 10 * expLiteral + ord(CH) - 48;
                            nextCH
                        until charSymTabBase[CH] <> INTCONST;
                    if expSign then
                        expMagnitude := expMagnitude - expLiteral
                    else
                        expMagnitude := expMagnitude + expLiteral;
                _); (* 2122 *)
                if expMagnitude <> 0 then _(
                    expValue := 1.0;
                    expSign := expMagnitude < 0;
                    expMagnitude := abs(expMagnitude);
                    expMultiple := 10.0;
                    if 18 < expMagnitude then _(
                        expMagnitude := 1;
                        error(58); (* errExponentGreaterThan18 *)
                    _);
                    repeat
                        if odd(expMagnitude) then
                            expValue := expValue * expMultiple;
                        expMagnitude := expMagnitude div 2;
                        if expMagnitude <> 0 then
                            expMultiple := expMultiple*expMultiple;
                    until expMagnitude = 0;
                    if expSign then
                        curToken.r := curToken.r / expValue
                    else
                        curToken.r := curToken.r * expValue;
                _);
                exit lexer
            _); (* INTCONST *) (*=m+*)
            CHARCONST: _(
(loop)          _(
                    for tokenIdx := 6 to 130 do _(
                        nextCH;
                        if charSymTabBase[CH] = CHARCONST then _(
                            nextCH;
                            if charSymTabBase[CH] <> CHARCONST then
                                exit loop
                            else
                                goto 2233;
                        _);
                        if atEOL then _(
2175:                       error(59); (* errEOLNInStringLiteral *)
                            exit loop
                        _) else if ((CH = chr(35B)) or
                                   (charSymTabBase[CH] = REALCONST))
                               and (charSymTabBase[PASINPUT@] = INTCONST)
                        then _(
                            expLiteral := 0;
                            for tokenLen to 3 do _(
                                nextCH;
                                if '7' < CH then
                                    error(
                                        errFirstDigitInCharLiteralGreaterThan3
                                    );
                                expLiteral := 8*expLiteral + ord(CH) - 48;
                            _);
                            if 255 < expLiteral then
                                error(errFirstDigitInCharLiteralGreaterThan3);
                            localBuf[tokenIdx] := chr(expLiteral);
                        _) else
2233:                       with PASINFOR do _(
                                if charEncoding = 3 then _(
                                    if (ch < '*') or ('_176' < CH) then
                                        curChar := chr(0)
                                    else
                                        curChar := iso2text[CH];
                                _) else if '_176' < CH then _(
                                    curChar := CH;
                                _) else if charEncoding = 0 then _(
                                    curChar := a0@[CH];
                                _) else if charEncoding = 1 then _(
                                    curChar := a1@[CH];
                                _) else if charEncoding = 4 then _(
                                    curChar := a4@[CH];
                                _) else _(
                                    curChar := CH;
                                _);
                                localBuf[tokenIdx] := curChar;
                            _);
                    _);
                    goto 2175
                _);
                strLen := tokenIdx - 6;
                if strLen = 0 then _(
                   error(61); (* errEmptyString *)
                   strLen := 1;
                   goto 2320
                _) else if strLen = 1 then _(
                    SY := CHARCONST;
                    tokenLen := 1;
                    curToken.c := chr(0);
                    unpck(localBuf[0], curToken.a);
                    pck(localBuf[tokenLen], curToken.a);
                    exit lexer;
                _) else 2320: _(
                    curVal.m := []; (* was '      ' *)
                    SY := LTSY;
                    unpck(localBuf[tokenIdx], curVal.a);
                    pck(localBuf[6], curToken.a);
                    curVal :=;
                    if 6 >= strLen then
                        exit lexer
                    else _(
                        curToken.i := FcstCnt;
                        tokenLen := 6;
                        (loop) _(
                            toFCST;
                            tokenLen := tokenLen + 6;
                            if tokenIdx <= tokenLen then (* < *)
                                exit lexer;
                            pck(localBuf[tokenLen], curVal.a);
                            goto loop
                        _)
                    _)
                _);
            _); (* CHARCONST *)
            LTSY: _(
                SY := RELOP;
                nextCH;
                if CH = '>' then _(
                    charClass := NEOP;
                    nextCH
                _) else if CH = '=' then _(
                    charClass := LEOP;
                    nextCH;
                _)
            _); (* LTOP *)
            GTSY: _(
                SY := RELOP;
                nextCH;
                if CH = '=' then _(
                    charClass := GEOP;
                    nextCH
                _)
            _); (* GTOP *)
            LPAREN: _(
                nextCH;
                if CH = '*' then _(
                    parseComment;
                    goto 1473
                _)
            _);
            COLON: _(
                nextCH;
                if CH = '=' then _(
                    nextCH;
                    SY := BECOMES;
                    charClass := NOOP
                _)
            _);
            NOTSY, LBRACK, MULOP, ADDOP, RELOP, RPAREN, RBRACK,
            COMMA, SEMICOLON, ARROW: _(
                nextCH;
            _);
            PERIOD: _(
                nextCH;
                if CH = '.' then _(
                    nextCH;
                    SY := COLON;
                    charClass := NOOP
                _) else _(
                    if prevSY = ENDSY then
                        dataCheck := true;
                _)
            _);
            end (* case *)
        _) else _( (* 2444 *)
            nextCH;
        _);
        prevSY := SY;
        if not pseudoZ and not (DebugCode in optSflags.m) then _(
            commentModeCH := '=';
            goto again;
        _);
        commentModeCH := ' ';
        int93z := int92z;
    _)
_); (* inSymbol *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure error;
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure skipToEnd;
var
    sym: symbol;
_(
    sym := SY;
    while (sym <> ENDSY) or (SY <> PERIOD) do _(
        sym := SY;
        inSymbol
    _);
    if CH = 'D' then
        while SY <> ENDSY do
            inSymbol;
    goto 9999;
_);
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
_( (* error *)
    errors := true;
    bool110z :=;
    if ((linePos <> prevErrPos) and (9 >= errsInLine))
        or (errno = 52)
    then _(
        write(' ');
        totalErrors := totalErrors + 1;
        errMapBase[errsInLine] := linePos;
        errsInLine := errsInLine + 1;
        prevErrPos := linePos;
        write('******', errno:0);
        printErrMsg(errno);
        if 60 < totalErrors then _(
            writeln;
            endOfLine;
            printErrMsg(53);
            skipToEnd
        _)
    _)
_);
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure skip(toset: setofsys);
_(
    while not (SY IN toset) do
        inSymbol;
_); (* skip *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure test1(sym: symbol; toset: setofsys);
_(
    if (SY <> sym) then _(
        requiredSymErr(sym);
        skip(toset)
    _) else
        inSymbol;
_); (* test1 *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure errAndSkip(errno: integer; toset: setofsys);
_(
    error(errno);
    skip(toset)
_); (* errAndSkip *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure parseLiteral(var litType: tptr; var litValue: word;
    allowSign: boolean);
label
    99;
var
    l3var1z: operator;
_(
    litValue := curToken;
    if (GTSY < SY) then _(
        if allowSign and (charClass IN [PLUSOP, MINUSOP]) then _(
            l3var1z := charClass;
            inSymbol;
            parseLiteral(litType, litValue, false);
            if (litType <> integerType) then _(
                error(62); (* errIntegerNeeded *)
                litType := integerType;
                litValue.i := 1;
            _) else _(
                if (l3var1z = MINUSOP) then
                    litValue.i := -litValue.i;
            _);
        _) else
99:     _(
            litType := NIL;
            error(errNoConstant);
        _)
    _) else
        case SY of
        IDENT: _(
            if (hashTravPtr = NIL) or
               (hashTravPtr@.cl <> ENUMID) then
                goto 99;
            litType := hashTravPtr@.typ;
            litValue.i := hashTravPtr@.value;
        _);
        INTCONST:
            litType := integerType;
        REALCONST:
            litType := realType;
        CHARCONST:
            litType := charType;
        LTSY:
            makeStringType(litType);
        GTSY: _(
            litType := pointerType;
            litValue.i := 74000C;
        _);
        end (* case *)
_); (* parseLiteral *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure P2672(var l3arg1z: irptr; l3arg2z: irptr);
var
    l3var1z: boolean;
    l3var2z: integer;
    l3var3z, l3var4z: irptr;
_(
    if l3arg1z = NIL then _(
        curVal.m := l3arg2z@.id.m * hashMask.m;
        mapAI(curVal.a, l3var2z);
        l3var1z := true;
        l3arg1z := symHashTabBase[l3var2z];
    _) else _(
        l3var1z := false;
    _);
    if (l3arg1z = l3arg2z) then _(
        if (l3var1z) then _(
            symHashTabBase[l3var2z] :=
                symHashTabBase[l3var2z]@.next;
        _) else _(
            l3arg1z := l3arg2z@.next;
        _);
    _) else _(
        l3var3z := l3arg1z;
        while (l3var3z <> l3arg2z) do _(
            l3var4z := l3var3z;
            if (l3var3z <> NIL) then _(
                l3var3z := l3var3z@.next;
            _) else _(
                exit
            _)
        _);
        l3var4z@.next := l3arg2z@.next;
    _)
_); (* P2672 *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function isFileType(typtr: tptr): boolean;
_(
    isFileType := (typtr@.k = kindFile) or
        (typtr@.k = kindRecord) and typtr@.flag;
_); (* isFileType *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function knownInType(var rec: irptr): boolean;
_(
    if (typelist <> NIL) then _(
        rec := typelist;
        while (rec <> NIL) do _(
            if (rec@.id = curIdent) then _(
                knownInType := true;
                exit
            _);
            rec := rec@.next;
        _)
    _);
    knownInType := false;
_); (* knownInType *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure checkSymAndRead(sym: symbol);
_(
    if (SY <> sym) then
        requiredSymErr(sym)
    else
        inSymbol
_); (* checkSymAndRead *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function typeCheck(type1, type2: tptr): boolean;
label
    1;
var
    baseMatch: boolean;
    kind1, kind2: kind;
    link: @typechain;
    basetyp1, basetyp2: tptr;
    enums1, enums2: irptr;
    span1, span2: integer;
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure allocWithTypeCheck;
_(
    new(link);
    link@ := [chain, basetyp1, basetyp2];
    chain := link;
    typeCheck := typeCheck(basetyp1, basetyp2);
_); (* allocWithTypeCheck *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function checkRecord(l4arg1z, l4arg2z: tptr): boolean;
var
    l4var1z: boolean;
_(
    l4var1z := (l4arg1z = NIL) or (l4arg2z = NIL);
    if (l4var1z) then _(
        checkRecord := l4arg1z = l4arg2z;
    _) else _(
        checkRecord := typeCheck(l4arg1z@.base, l4arg2z@.base) and
                 checkRecord(l4arg1z@.next, l4arg2z@.next);
    _);
_); (* checkRecord *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
_( (* typeCheck *)
    rangeMismatch := false;
    if (type1@.k = kindRange) then _(
        typ120z := type1@.base;
    _) else _(
        typ120z := type1;
    _);
    if not checkTypes or (type1 = type2) then
1:      typeCheck := true
    else
        with type1@ do _(
            kind1 := k;
            kind2 := type2@.k;
            if (kind1 = kind2) then _(
                case kind1 of
                kindReal:
                    (* empty *);
                kindScalar: _(
(chain)             if (type1@.numen = type2@.numen) then _(
                        enums1 := type1@.enums;
                        enums2 := type2@.enums;
                        while (enums1 <> NIL) and (enums2 <> NIL) do _(
                            if (enums1@.id <> enums2@.id) then
                                exit chain;
                            enums1 := enums1@.list;
                            enums2 := enums2@.list;
                        _);
                        if (enums1 = NIL) and (enums2 = NIL) then
                            goto 1;
                    _)
                _);
                kindRange: _(
                    baseMatch := (type1@.base = type2@.base);
                    typ120z := type1@.base;
                    rangeMismatch := (type1@.left <> type2@.left) or
                                (type1@.right <> type2@.right);
                    typeCheck := baseMatch;
                    exit
                _);
                kindPtr: _(
                    if (type1 = pointerType) or (type2 = pointerType) then
                        goto 1;
                    basetyp1 := type1@.base;
                    basetyp2 := type2@.base;
                    if (chain <> NIL) then _(
                        link := chain;
                        while (link <> NIL) do with link@ do _(
                            if (type1 = basetyp1) and
                               (type2 = basetyp2) or
                               (type2 = basetyp1) and
                               (type1 = basetyp2) then
                                goto 1;
                            link := next;
                        _);
                        allocWithTypeCheck;
                    _) else _(
                        setup(type1);
                        allocWithTypeCheck;
                        chain := NIL;
                        rollup(type1);
                        exit
                    _)
                _);
                kindSet:
                    goto 1;
                kindArray: _(
                    with type1@.range@ do
                        span1 := right - left;
                    with type2@.range@ do
                        span2 := right - left;
                    if typeCheck(type1@.base, type2@.base) and
                       (span1 = span2) and
                       (type1@.pck = type2@.pck) and
                       not rangeMismatch then _(
                        if type1@.pck then _(
                            if (type1@.pcksize = type2@.pcksize) then
                                goto 1
                        _) else
                            goto 1
                    _)
                _);
                kindFile: _(
                    if typeCheck(type1@.base, type2@.base) then
                        goto 1;
                _);
                kindRecord: _(
                    if checkRecord(type1@.first, type2@.first) then
                        goto 1;
                _)
                end (* case *)
            _) else _(
                if (kind1 = kindRange) then _(
                    rangeMismatch := true;
                    typ120z := type2;
                    if (type1@.base = type2) then
                        goto 1;
                _) else if (kind2 = kindRange) and
                          (type1 = type2@.base) then
                    goto 1;
            _);
            typeCheck := false;
        _)
_); (* typeCheck *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function F3307(l3arg1z: irptr): integer;
var
    l3var1z: integer;
    l3var2z: irptr;
_(
    l3var2z := l3arg1z@.argList;
    l3var1z := 0;
    if (l3var2z <> NIL) then
        while (l3var2z <> l3arg1z) do _(
            l3var1z := l3var1z + 1;
            l3var2z := l3var2z@.list;
        _);
    F3307 := l3var1z;
_); (* F3307 *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function makeNameWithStars(isProc: boolean): bitset;
var
    wantBoth: boolean;
_(
    wantBoth := not isProc and (extSymAdornment = 0);
    if curVal.m * [0..5] = [] then _(
        curVal := curVal;
        besm(ASN64-6);
        curVal := ;
        if wantBoth or (extSymAdornment = 1) then
            curVal.m := curVal.m + [44, 46];
        while curVal.m * [0..11] = [] do _(
            curVal := curVal;
            besm(ASN64-6);
            curVal := ;
        _);
        if curVal.m * [0..5] = [] then _(
            if wantBoth then
                curVal.m := [2, 4] + curVal.m
            else _(
                curVal := curVal;
                besm(ASN64-6);
                curVal := ;
            _)
        _)
    _);
    makeNameWithStars := curVal.m;
_); (* makeNameWithStars *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure formOperator(l3arg1z: opgen);
var
    l3int1z, l3int2z, l3int3z: integer;
    nextInsn: integer;
    l3var5z: eptr;
    flags: opflg;
    l3var7z,
    l3var8z: word;
    l3bool9z: boolean;
    l3var10z, l3var11z: word;
    saved: @insnltyp;
    l3bool13z: boolean;
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure genOneOp;
label
    3556;
var
    insnBufIdx: integer;
    l4var2z, l4var3z, m: integer;
    l4var5z: word;
    l4inl6z, l4inl7z, l4inl8z: oiptr;
    l4var9z: integer;
    insnBuf: array [1..200] of word;
    curInsn: word;
    tempInsn: word;
    l4oi212z: oiptr;
    l4var213z: boolean;
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure P3363;
_(
    if l4var213z then
        form1Insn(insnTemp[XTA])
    else
        form1Insn(KXTA+E1)
_); (* P3363 *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure  addInsnToBuf(insn: integer);
_(
    insnBuf[insnBufIdx].i := insn;
    insnBufIdx := insnBufIdx + 1;
_); (* addInsnToBuf *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure add2InsnsToBuf(insn1, insn2: integer);
_(
    insnBuf[insnBufIdx].i := insn1;
    insnBuf[insnBufIdx+1].i := insn2;
    insnBufIdx := insnBufIdx + 2;
_); (* add2InsnsToBuf *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function F3413: boolean;
_(
    l4inl7z := l4inl6z;
    while l4inl7z <> NIL do _(
        if (l4inl7z@.mode = curInsn.i) then _(
            F3413 := true;
            while (l4inl7z@.code = macro) do _(
                l4inl7z := ptr(l4inl7z@.offset);
            _);
            exit
        _) else _(
            l4inl7z := l4inl7z@.next;
        _)
    _);
    F3413 := false;
_); (* F3413 *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure addJumpInsn(opcode: integer);
_(
    if not F3413 then _(
        new(l4inl7z);
        l4inl7z@.next := l4inl6z;
        l4inl7z@.mode := curInsn.i;
        l4inl7z@.code := 0;
        l4inl7z@.offset := 0;
        l4inl6z := l4inl7z;
    _);
    addInsnToBuf(macro + opcode + ord(l4inl7z))
_); (* addJumpInsn *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
_( (* genOneOp *)
    if insnList = NIL
        then exit;
    set145z := set145z + insnList@.regsused;
    l4oi212z := insnList@.next2;
    l4var9z := 370007B;
    insnBufIdx := 1;
    if l4oi212z = NIL then
        exit;
    l4inl6z := NIL;
    while l4oi212z <> NIL do _(
        tempInsn.i := l4oi212z@.code;
        m := tempInsn.i - macro;
        curInsn.i := l4oi212z@.offset;
        case l4oi212z@.mode of
         0: ;
         1: if arithMode <> 1 then _(
                addInsnToBuf(370007B);
                arithMode := 1
            _);
         2: arithMode := 1;
         3: if arithMode <> 2 then _(
                addInsnToBuf(insnTemp[NTR]);
                arithMode := 2;
            _);
         4: arithMode := 2;
        end; (* case *)
        l4oi212z := l4oi212z@.next;
        if m >= 0 then _(
            case m of
            mcCARD: _(
                add2InsnsToBuf(KACX, KAEX+ZERO);
            _);
            21: goto 3556;
            0:  addJumpInsn(insnTemp[UZA]);
            1:  addJumpInsn(insnTemp[U1A]);
            2: _(
                tempInsn.i := curInsn.i mod 4096;
                curInsn.i := curInsn.i div 4096;
                addJumpInsn(insnTemp[UJ]);
                curInsn.i := tempInsn.i;
3556:           if F3413 then
                    addInsnToBuf(2*macro+ord(l4inl7z))
                else
                    error(206);
            _);
            3: _(
                 tempInsn.i := curInsn.i mod 4096;
                 curInsn.i := curInsn.i div 4096;
                 l4var213z :=  F3413;
                 l4inl8z := l4inl7z;
                 curInsn.i := tempInsn.i;
                 l4var213z := l4var213z & F3413;
                 if l4var213z then
                    with l4inl7z@ do _(
                        code := macro;
                        offset := ord(l4inl8z);
                    _)
                else
                    error(207);
            _);
            20: addInsnToBuf(3*macro + curInsn.i);
            mcPOP: _(
                with insnBuf[insnBufIdx-1] do if m * [21:23, 28:35] = [] then
                    m := m + [35]
                else
                    addInsnToBuf(KXTA+SP)
            _);
            mcPUSH:
(blk)       _(
                if l4oi212z <> NIL then _(
                    tempInsn.i := l4oi212z@.code;
                    if tempInsn.m * [21:23, 28:35] = [32] then _(
                        l4oi212z@.code :=
                            tempInsn.i - insnTemp[XTA] + insnTemp[XTS];
                        exit blk
                    _)
                _);
                addInsnToBuf(KATX+SP);
            _);
            mcACC2ADDR:  add2InsnsToBuf(KATI+14, KUTC+I14);
            mcMULTI: _(
                addInsnToBuf(getHelperProc(12));        (* P/MI *)
            _);
            mcADDSTK2REG:  add2InsnsToBuf(KWTC+SP, KUTM+
                               indexreg[curInsn.i]);
            mcADDACC2REG:  add2InsnsToBuf(KATI+14, KJADDM+I14 + curInsn.i);
            mcODD: _(
                add2InsnsToBuf(KAAX+E1, KAEX+ZERO);
            _);
            mcROUND: _(
                addInsnToBuf(KADD+REAL05);                (* round *)
                add2InsnsToBuf(KNTR+7, KADD+ZERO)
            _);
            mcSQRR: _(
                add2InsnsToBuf(KATX+SP, KMUL+SP);   (* sqr *)
            _);
            mcSQRI: _(
                add2InsnsToBuf(KATX+SP, KAEX+MULTMASK);   (* sqrint *)
                add2InsnsToBuf(KMUL+SP, KYTA+64)
            _);
            14: add2InsnsToBuf(indexreg[curInsn.i] + KVTM,
                               KITA + curInsn.i);
            mcMINEL: _(
                add2InsnsToBuf(KANX+ZERO, KSUB+PLUS1);   (* minel *)
            _);
            16: add2InsnsToBuf(insnTemp[XTA], KATX+SP + curInsn.i);
            17: _(
                addInsnToBuf(KXTS);
                add2InsnsToBuf(KATX+SP+1, KUTM+SP + curInsn.i)
            _);
            18: add2InsnsToBuf(KVTM+I10, getHelperProc(65)); (* P/B7 *)
            19: _(
                addInsnToBuf(KVTM+I14);
                add2InsnsToBuf(KXTA+SP, KATX+I14)
            _);
            22: _(
                add2InsnsToBuf(KVTM+I14, KXTA+I14);
                curVal.i := 40077777C;
                add2InsnsToBuf(allocSymtab(curVal.m) + (KXTS+SP),
                               KAAX+I8 + curInsn.i);
                add2InsnsToBuf(KAEX+SP, KATX+I14)
            _);
            end; (* case *)
        _) else _( (* 4003 *)
            if 28 in tempInsn.m then _(
                addInsnToBuf(getValueOrAllocSymtab(curInsn.i)+tempInsn.i);
            _) else _(
                curval.i := curInsn.i mod 32768;
                if curVal.i < 2048 then
                    addInsnToBuf(tempInsn.i + curInsn.i)
                else
                if (curVal.i >= 28672) or (curVal.i < 4096) then _(
                    addInsnToBuf(
                        allocSymtab((curVal.m + [24])*halfWord)
                        + tempInsn.i - 28672);
                _) else _(
                    add2InsnsToBuf(getValueOrAllocSymtab(curVal.i)
                                   + insnTemp[UTC], tempInsn.i);
                _)
            _)
        _)
    _); (* 4037 *)
    insnBufIdx := insnBufIdx-1;
    for m := insnBufIdx downto 1 do _(
        curInsn := insnBuf[m];
        if (curInsn.i = insnTemp[NTR]) or
           (curInsn.i = 370007B)
        then _(
            l4var3z := m - 1;
            l4var213z := false;
(loop)      if l4var3z < 1 then exit loop else _(
                tempInsn.m := insnBuf[l4var3z].m * [28:32];
                if (tempInsn.i = CUTC) or (tempInsn.i = CWTC)
                then _(
                    l4var3z := l4var3z-1;
                    goto loop;
                _)
            _);
(* one word shorter
(loop)      while l4var3z >= 1 do _(
                tempInsn.m := insnBuf[l4var3z].m * [28:32];
                if (tempInsn.i # CUTC) and (tempInsn.i # CWTC)
                then
                    exit loop;
                l4var3z := l4var3z-1;
            _);
*)
            l4var3z := l4var3z + 1;
            if (l4var3z <> m) then _(
                for l4var2z := m-1 downto l4var3z do _(
                    insnBuf[l4var2z+1] := insnBuf[l4var2z]
                _);
            _);
            insnBuf[l4var3z] := curInsn;
        _); (* 4103 *)
    _);
    for m to insnBufIdx do
(iter)  _(
        curInsn := insnBuf[m];
        tempInsn.m := curInsn.m * [0, 1, 3, 23:32];
        if tempInsn.i = KATX+SP then _(
            l4var2z := m + 1;
            while insnBufIdx + 1 <> l4var2z do _(
                curVal.m := insnBuf[l4var2z].m * [0, 1, 3, 23, 28:35];
                tempInsn.m := curVal.m * [0, 1, 3, 23, 28:32];
                if curVal.i = insnTemp[XTA] then _(
                    insnBuf[l4var2z].m :=
                        insnBuf[l4var2z].m mod [32, 34, 35];
                    exit iter;
                _) else if curVal.i = insnTemp[ITA] then _(
                    insnBuf[l4var2z].m := insnBuf[l4var2z].m + [35];
                    exit iter;
                _) else if (curVal.i = insnTemp[NTR]) or
                    (tempInsn.i = insnTemp[UTC]) or
                    (tempInsn.i = insnTemp[WTC]) or
                    (tempInsn.i = insnTemp[VTM])
                then
                    l4var2z := l4var2z + 1
                else _(
                    l4var2z := insnBufIdx + 1;
                _)
            _);
        _); (* 4150 *)
        if curInsn.i = insnTemp[UTC] then
            exit iter;
        if curInsn.i < macro then _(
            form1Insn(curInsn.i);
            tempInsn.m := curInsn.m * [28:32];
            if (tempInsn.i = 3100000C) or (* VJM *)
               (tempInsn.i = 0500000C)    (* ELFUN *)
            then _(
                padToLeft;
                prevOpcode := 1;
            _);
            exit iter;
        _);
        if (curInsn.i >= 3*macro) then _(
            curInsn.i := curInsn.i - (3*macro);
            if curInsn.i >= 4096 then _(
                l4var213z := true;
                curInsn.i := curInsn.i - 4096;
            _) else _(
                l4var213z := false;
            _);
            if (curInsn.i = 0) then
                form1Insn(insnTemp[UZA] + moduleOffset + 2);
            P3363;
            form1Insn(insnTemp[UJ] + 2 + moduleOffset);
            padToLeft;
            if (curInsn.i <> 0) then _(
                if (not F3413) then
                    error(211);
                P0715(0, l4inl7z@.code);
            _);
            l4var213z := not l4var213z;
            P3363;
            padToLeft;
            exit iter
        _); (* 4230 *)
        if (curInsn.i >= 2*macro) then _(
            l4inl7z := ptr(curInsn.i - (2*macro));
            P0715(0, l4inl7z@.code);
            l4inl7z@.offset := moduleOffset;
        _) else _(
            curInsn.i := curInsn.i - macro;
            curVal.m := curInsn.m * [0, 1, 3, 28:32];
            jumpType := curVal.i;
            curVal.m := [0, 1, 3, 33:47] * curInsn.m;
            l4inl7z := ptr(curVal.i);
            formJump(l4inl7z@.code);
            jumpType := insnTemp[UJ];
            exit iter
        _)
    _); (* loop *)
    insnList := NIL;
    while (l4inl6z <> NIL) do _(
        with l4inl6z@ do
            if offset = 0 then _(
                jumpTarget := code;
                exit;
            _) else
                l4inl6z := next;
    _);
    set146z := set146z - set145z;
_); (* genOneOp *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure addToInsnList(insn: integer);
var elt: oiptr;
_(
    new(elt);
    with elt@ do _(
        next := NIL;
        mode := 0;
        code := insn;
        offset := 0;
    _);
    with insnList@ do _(
        if next = NIL then
            next2 := elt
        else
            next@.next := elt;
        next := elt
    _)
_); (* addToInsnList *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure addInsnAndOffset(insn, l4arg2z: integer);
_(
    addToInsnList(insn);
    insnlist@.next@.offset := l4arg2z
_); (* addInsnAndOffset *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure addxToInsnList(insn: integer);
var
    elt: oiptr;
_(
    new(elt);
    with elt@ do _(
        next := insnList@.next2;
        mode := 0;
        code := insn;
        offset := 0;
    _);
    if (insnList@.next2 = NIL) then _(
        insnList@.next := elt;
    _);
    insnList@.next2 := elt;
_); (* addxToInsnList *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure prepLoad;
label
    4545, 4602;
var
    helper, l4int2z, l4int3z: integer;
    l4typ4z: tptr;
    l4var5z: kind;
    l4st6z: state;
    l4bool7z, l4bool8z, l4bool9z: boolean;
_(
    l4typ4z := insnList@.typ;
    with insnList@ do _(
        case ilm of
        ilCONST: _(
            curVal := ilf5;
            if (l4typ4z@.size = 1) then
                curVal.i := getFCSToffset;
            addToInsnList(constRegTemplate + curInsnTemplate + curVal.i);
        _);
        il1: _(
            helper := insnList@.ilf7;
            l4int2z := insnList@.ilf5.i;
            l4int3z := insnList@.ilf6;
            if (15 < helper) then _(
                (* empty *)
            _) else _(
                if (helper = 15) then _( (* P/CP *)
                    addToInsnList(macro + mcACC2ADDR);
                _) else _(
                    helper := indexreg[insnList@.ilf7];
                    if (l4int2z = 0) and (insnList@.st = st0) then _(
                        addInsnAndOffset(helper + curInsnTemplate,
                                         l4int3z);
                        goto 4602;
                    _) else
                        addToInsnList(helper + insnTemp[UTC]);
                _)
            _);
            l4st6z := insnList@.st;
            if l4st6z = st0 then _(
                addInsnAndOffset(l4int2z + curInsnTemplate, l4int3z);
            _) else _(
                l4var5z := l4typ4z@.k;
                if (l4var5z < kindSet) or
                   (l4var5z = kindRecord) and (s6 in optSflags.m) then _(
                    l4bool7z := true;
                    l4bool8z := typeCheck(l4typ4z, integerType);
                _) else _(
                    l4bool7z := false;
                    l4bool8z := false;
                _);
                if l4st6z = st1 then _(
                    if (l4int3z <> l4int2z) or
                       (helper <> 18) or (* P/RC *)
                       (l4int2z <> 0) then
                        addInsnAndOffset(l4int2z + insnTemp[XTA],
                                         l4int3z);
                    l4int3z := insnList@.shift;
                    l4int2z := insnList@.width;
                    l4bool9z := true;
                    helper := l4int3z + l4int2z;
                    if l4bool7z then _(
                        if (30 < l4int3z) then _(
                            addToInsnList(ASN64-48 + l4int3z);
                            addToInsnList(insnTemp[YTA]);
                            if (helper = 48) then (* P/RDR *)
                                l4bool9z := false;
                        _) else _(
                            if (l4int3z <> 0) then
                                addToInsnList(ASN64 + l4int3z);
                        _); (* 4477 *)
                        if l4bool9z then _(
                            curVal.m := [(48 - l4int2z)..47];
                            addToInsnList(KAAX+I8 + getFCSToffset);
                        _)
                    _) else _( (* 4511 *)
                        if (helper <> 48) then
                            addToInsnList(ASN64-48 + helper);
                        curVal.m := [0..(l4int2z-1)];
                        addToInsnList(KAAX+I8 + getFCSToffset);
                    _); (* 4525 *)
                    if l4bool8z then
                        addToInsnList(KAEX+ZERO);
                _) else _( (* 4531 *)
                    if l4bool7z then
                        helper := ord(l4bool8z)+74 (* P/LDAR[IN] *)
                    else
                        helper := 56; (* P/RR *)
                    addToInsnList(getHelperProc(helper));
                    insnList@.next@.mode := 1;
                _)
            _);
            goto 4545;
        _);
        il2: _(
4545:       if bool49z and (l4typ4z = booleanType) and
               (16 in insnList@.regsused) then
                addToInsnList(KAEX+E1);
        _);
        il3: _( (* 4555 *)
            if bool49z then
                addInsnAndOffset(macro+20,
                    ord(16 in insnList@.regsused)*10000B + insnList@.ilf5.i);
        _);
        end; (* case *)
4602:
    _); (* with *)
    with insnList@ do _(
        ilm := il2;
        regsused := regsused + [0];
    _);
_); (* prepLoad *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure P4606;
_(
    prepLoad;
    addToInsnList(macro + mcPUSH)
_); (* P4606 *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure P4621(reg: integer);
label
    4650, 4654;
var
    l4var1z: word;
    l4int2z, opCode, l4var4z, l4var5z,
    l4var6z, regField: integer;
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure P4613;
_(
    l4var1z.i := insnList@.ilf6;
    l4var1z.i := l4var1z.i mod 32768;
    l4var6z := l4var1z.i
_); (* P4613 *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
_( (* P4621 *)
    with insnList@ do _(
        l4int2z := ilf7;
        opCode := insnTemp[VTM];
        regField := indexreg[reg];
        l4var4z := ilf5.i;
        regsused := regsused + [reg];
        if (ilm = ilCONST) then _(
            curVal := ilf5;
            if (typ@.size = 1) then
                curVal.i := addCurValToFCST;
            l4var6z := curVal.i;
            l4var5z := 74001B;
            goto 4654;
        _) else if (l4int2z = 18) then _(
4650:       P4613;
            if (l4var4z = indexreg[1]) then _(
                l4var5z := 74003B;
4654:           l4var1z.i := macro * l4var5z + l4var6z;
                l4var6z := allocSymtab(l4var1z.m * [12:47]);
                addToInsnList(regField + opCode + l4var6z);
            _) else if (l4var4z <> 0) then _(
                addInsnAndOffset(l4var4z + insnTemp[UTC], l4var6z);
                addToInsnList(regField + opCode);
            _) else _(
                addInsnAndOffset(regField + opCode, l4var6z);
            _)
        _) else if (l4int2z = 17) then _(
            P4613;
            l4var4z := insnList@.ilf6;
            l4var5z := insnList@.next@.code - insnTemp[UTC];
            if (l4var4z <> 0) then _(
                l4var1z.i := macro * l4var5z + l4var4z;
                l4var5z := allocSymtab(l4var1z.m * [12:47]);
            _);
            insnList@.next@.code := regField + l4var5z + opCode;
        _) else if (l4int2z = 16) then _(
            P4613;
            if (l4var4z <> 0) then
                addToInsnList(l4var4z + insnTemp[UTC]);
            addInsnAndOffset(regField + opCode, l4var6z);
        _) else if (l4int2z = 15) then _(
            addToInsnList(insnTemp[ATI] + reg);
            opCode := insnTemp[UTM];
            goto 4650;
        _) else _(
            addToInsnList(indexreg[l4int2z] + insnTemp[UTC]);
            goto 4650;
        _)
    _); (* with *)
    insnList@.ilm := il1;
    insnList@.ilf7 := reg;
    insnList@.ilf6 := 0;
    insnList@.ilf5.i := 0;
_); (* P4621 *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure prepStore;
var
    l4int1z: integer;
    l4int2z, l4int3z: integer;
    l4bool4z, l4bool5z: boolean;
    l4st6z: state;
    l4var7z: kind;
_(
    with insnList@ do
        l4int1z := ilf7;
    if (15 < l4int1z) then _(
        (* nothing? *)
    _) else if (l4int1z = 15) then _(
        addToInsnList(macro + mcACC2ADDR)
    _) else _(
        addToInsnList(indexreg[l4int1z] + insnTemp[UTC]);
    _);
    l4bool4z := 0 in insnList@.regsused;
    l4st6z := insnList@.st;
    if (l4st6z <> st0) or l4bool4z then
        addxToInsnList(macro + mcPUSH);
    if (l4st6z = st0) then _(
        if (l4bool4z) then _(
            addInsnAndOffset(insnList@.ilf5.i + insnTemp[UTC],
                             insnList@.ilf6);
            addToInsnList(macro+19);
        _) else _(
            addInsnAndOffset(insnList@.ilf5.i, insnList@.ilf6);
        _)
    _) else _(
        l4var7z := insnList@.typ@.k;
        l4int1z := insnList@.typ@.bits;
        l4bool5z := (l4var7z < kindSet) or
                     (l4var7z = kindRecord) and (S6 in optSflags.m);
        if (l4st6z = st1) then _(
            l4int2z := insnList@.shift;
            l4int3z := l4int2z + insnList@.width;
            if l4bool5z then _(
                if (l4int2z <> 0) then
                    addxToInsnList(ASN64 - l4int2z);
            _) else _(
                if (l4int3z <> 48) then
                    addxToInsnList(ASN64 + 48 - l4int3z);
            _);
            addInsnAndOffset(insnTemp[UTC] + insnList@.ilf5.i,
                             insnList@.ilf6);
            curVal.m := [0..47] - [(48-l4int3z)..(47 -l4int2z)];
            addInsnAndOffset(macro+22, getFCSToffset);
        _) else _(
            if not l4bool5z then _(
                l4int2z := (insnList@.width - l4int1z);
                if (l4int2z <> 0) then
                    addxToInsnList(ASN64 - l4int2z);
                addxToInsnList(insnTemp[YTA]);
                addxToInsnList(ASN64 - l4int1z);
            _);
            addToInsnList(getHelperProc(77)); (* "P/STAR" *)
            insnList@.next@.mode := 1;
        _)
    _)
_); (* prepStore *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure mkTempVar(op: operator);
_(
    addInsnAndOffset(curFrameRegTemplate, curVarOff);
    new(curExpr);
    with curExpr@ do
        typ := insnList@.typ;
    genOneOp;
    curExpr@.op := op;
    curExpr@.num1 := curVarOff;
    curVarOff := curVarOff + 1;
    if (l2int21z < curVarOff) then
        l2int21z := curVarOff;
_); (* mkTempVar *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function insnCount: integer;
var
    cnt: integer;
    cur: oiptr;
_(
    cnt := 0;
    cur := insnList@.next2;
    while cur <> NIL do _(
        cur := cur@.next;
        cnt := cnt + 1;
    _);
    insnCount := cnt;
_); (* insnCount *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure genFullExpr(exprToGen: eptr);
label
    7567, 7760, 10075, 10122;
var
    arg1Const, arg2Const: boolean;
    otherIns: @insnltyp;
    arg1Val, arg2Val: word;
    curOP: operator;
    work: integer;
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure P5155;
_(
    prepLoad;
    insnList@.ilm := il1;
    insnList@.st := st0;
    insnList@.ilf6 := 0;
    insnList@.ilf5.i := 0;
    insnList@.ilf7 := 18;
_); (* P5155 *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure genDeref;
label
    5220;
var
    l5var1z, l5var2z: word;
    doPtrCheck: boolean;
_(
    doPtrCheck := checkBounds and not (NoPtrCheck in optSflags.m)
               and (curOP = DEREF);
    if not doPtrCheck and (
        (insnList@.st = st0) or
        (insnList@.st = st1) and
        (insnList@.shift = 0))
    then _(
        l5var1z.i := insnList@.ilf7;
        l5var2z.i := insnList@.ilf6;
        if (l5var1z.i = 18) or (l5var1z.i = 16) then _(
5220:       addInsnAndOffset((insnList@.ilf5.i + insnTemp[WTC]), l5var2z.i);
        _) else _(
            if (l5var1z.i = 17) then _(
                if (l5var2z.i = 0) then _(
                    insnList@.next@.code := insnList@.next@.code +
                                                insnTemp[XTA];
                _) else
                    goto 5220;
            _) else if (l5var1z.i = 15) then _(
                addToInsnList(macro + mcACC2ADDR);
                goto 5220;
            _) else _(
                addInsnAndOffset((indexreg[l5var1z.i] + insnTemp[WTC]),
                                 l5var2z.i);
            _)
        _)
    _) else _(
        P5155;
        if (doPtrCheck) then _(
            addToInsnList(KVTM+I14 + lineCnt);
            addToInsnList(getHelperProc(7)); (* "P/CA"*)
            insnList@.next@.mode := 1;
        _);
        addToInsnList(macro + mcACC2ADDR);
    _);
    insnList@.ilf6 := 0;
    insnList@.ilf5.i := 0;
    insnList@.ilf7 := 16;
_); (* genDeref *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure genHelper;
_(
    P4606;
    saved := insnList;
    insnList := otherIns;
    prepLoad;
    addToInsnList(getHelperProc(nextInsn));
    insnList@.regsused := insnList@.regsused + saved@.regsused + [11:14];
    saved@.next@.next := insnList@.next2;
    insnList@.next2 := saved@.next2;
_); (* genHelper *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure prepMultiWord;
var
    l5var1z: boolean;
    l5var2z: @insnltyp;
_(
    l5var1z := 12 in otherIns@.regsused;
    P4621(12);
    if (l5var1z) then _(
        addToInsnList(KITA+12);
        addToInsnList(macro + mcPUSH);
    _);
    l5var2z := insnList;
    insnList := otherIns;
    P4621(14);
    if (l5var1z) then _(
        addToInsnList(macro + mcPOP);
        addToInsnList(KATI+12);
    _);
    l5var2z@.regsused := (insnList@.regsused + l5var2z@.regsused);
    l5var2z@.next@.next := insnList@.next2;
    l5var2z@.next := insnList@.next;
    insnList := l5var2z;
_); (* prepMultiWord *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure genCheckBounds(l5arg1z: tptr);
var
    l5var1z: integer;
    l5var2z, l5var3z, l5var4z: word;
_(
    l5var1z := l5arg1z@.checker;
    if (l5var1z = 0) then _(
        curVal.i := l5arg1z@.left;
        l5var4z.i := l5arg1z@.right;
        if (l5arg1z@.base <> integerType) then _(
            curVal.m := curVal.m * [7:47];
            l5var4z.m := l5var4z.m * [7:47];
        _);
        prevOpcode := -1;
        formAndAlign(KUJ+5 + moduleOffset);
        l5arg1z@.checker := moduleOffset;
        l5var1z := moduleOffset;
        P0715(1, l5var4z.i);
        formAndAlign(KUJ+I13);
    _);
    prepLoad;
    addToInsnList(KVTM+I14 + lineCnt);
    addToInsnList(KVJM+I13 + l5var1z);
    insnList@.next@.mode := 1;
_); (* genCheckBounds *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure negateCond;
_(
    if (insnList@.ilm = ilCONST) then _(
        insnList@.ilf5.b := not insnList@.ilf5.b;
    _) else _(
        insnList@.regsused := insnList@.regsused mod [16];
    _)
_); (* negateCond *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure tryFlip(commutes: boolean);
label
    100, 22, 33;
var
    l5var1z: integer;
    l5var2z: @insnltyp;
_(
    if not (0 in otherIns@.regsused) then _(
        l5var1z := 0;
    _) else if not (0 in insnList@.regsused) then _(
        l5var1z := ord(commutes) + 1;
    _) else _(
        l5var1z := 3;
    _);
    case l5var1z of
    0:
100: _(
        prepLoad;
        saved := insnList;
        insnList := otherIns;
        curInsnTemplate := nextInsn;
        prepLoad;
        curInsnTemplate := insnTemp[XTA];
    _);
    1:
        if (nextInsn = insnTemp[SUB]) then _(
            nextInsn := insnTemp[RSUB];
            goto 22;
        _) else
            goto 33;
   2:
22: _(
        saved := insnList;
        insnList := otherIns;
        otherIns := saved;
        goto 100;
    _);
    3:
33: _(
        prepLoad;
        addToInsnList(indexreg[15] + nextInsn);
        l5var2z := insnList;
        insnList := otherIns;
        P4606;
        saved := insnList;
        insnList := l5var2z;
    _);
    end; (* case *)
    insnList@.next@.mode := 0;
    saved@.next@.next := insnList@.next2;
    insnList@.next2 := saved@.next2;
    insnList@.regsused := insnList@.regsused + [0];
_); (* tryFlip *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure genBoolAnd;
var
    l5var1z, l5var2z: boolean;
    l5var3z, l5var4z, l5var5z, l5var6z, l5var7z: integer;
    l5ins8z: @insnltyp;
    l5var9z: word;
_(
    if (arg1Const) then _(
        if (arg1Val.b) then
            insnList := otherIns;
    _) else if (arg2Const) then _(
        if (not arg2Val.b) then
            insnList := otherIns;
    _) else _(
        l5var1z := 16 in insnList@.regsused;
        l5var2z := 16 in otherIns@.regsused;
        l5var5z := int94z;
        int94z := int94z + 1;
        bool49z := false;
        l5var6z := ord(l5var1z) + macro;
        l5var7z := ord(l5var2z) + macro;
        if (insnList@.ilm = il3) then _(
            l5var3z := insnList@.ilf5.i;
        _) else _(
            l5var3z := 0;
            prepLoad;
        _);
        if (otherIns@.ilm = il3) then _(
            l5var4z := otherIns@.ilf5.i;
        _) else _(
            l5var4z := 0;
        _);
        l5var9z.m := (insnList@.regsused + otherIns@.regsused);
        if (l5var3z = (0)) then _(
            if (l5var4z = (0)) then _(
                addInsnAndOffset(l5var6z, l5var5z);
                l5ins8z := insnList;
                insnList := otherIns;
                prepLoad;
                addInsnAndOffset(l5var7z, l5var5z);
            _) else _(
                if (l5var2z) then _(
                    addInsnAndOffset(l5var6z, l5var5z);
                    l5ins8z := insnList;
                    insnList := otherIns;
                    addInsnAndOffset(macro + 2,
                                     10000B * l5var5z + l5var4z);
                _) else _(
                    addInsnAndOffset(l5var6z, l5var4z);
                    l5var5z := l5var4z;
                    l5ins8z := insnList;
                    insnList := otherIns;
                _)
            _);
        _) else _(
            if (l5var4z = (0)) then _(
                if (l5var1z) then _(
                    addInsnAndOffset(macro + 2,
                                     10000B * l5var5z + l5var3z);
                    l5ins8z := insnList;
                    insnList := otherIns;
                    prepLoad;
                    addInsnAndOffset(l5var7z, l5var5z);
                _) else _(
                    l5ins8z := insnList;
                    insnList := otherIns;
                    prepLoad;
                    addInsnAndOffset(l5var7z, l5var3z);
                    l5var5z := l5var3z;
                _);
            _) else _(
                if (l5var1z) then _(
                    if (l5var2z) then _(
                        addInsnAndOffset(macro + 2,
                                         10000B * l5var5z + l5var3z);
                        l5ins8z := insnList;
                        insnList := otherIns;
                        addInsnAndOffset(macro + 2,
                                         10000B * l5var5z + l5var4z);
                    _) else _(
                        addInsnAndOffset(macro + 2,
                                         10000B * l5var4z + l5var3z);
                        l5ins8z := insnList;
                        insnList := otherIns;
                        l5var5z := l5var4z;
                    _)
                _) else _(
                    l5ins8z := insnList;
                    insnList := otherIns;
                    l5var5z := l5var3z;
                    if (l5var2z) then
                        addInsnAndOffset(macro + 2,
                                         10000B * l5var3z + l5var4z)
                    else
                        addInsnAndOffset(macro + 3,
                                         10000B * l5var3z + l5var4z);
                _)
            _)
        _);
        insnList@.regsused := l5var9z.m - [16];
        l5ins8z@.next@.next := insnList@.next2;
        insnList@.next2 := l5ins8z@.next2;
        insnList@.ilm := il3;
        insnList@.ilf5.i := l5var5z;
        bool49z := true;
    _)
_); (* genBoolAnd *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure genGetElt;
var
    l5var1z, dimCnt, curDim, l5var4z, l5var5z, l5var6z,
        l5var7z, l5var8z: integer;
    insnCopy: insnltyp;
    copyPtr, l5ins21z: @insnltyp;
    l5var22z, l5var23z: word;
    l5var24z: boolean;
    l5var25z: boolean;
    l5var26z, l5var27z: tptr;
    l5ilm28z: ilmode;
    l5var29z: eptr;
    getEltInsns: array [1..10] of @insnltyp;
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function myminel(l6arg1z: bitset): integer;
_(
    myminel := minel(l6arg1z);
_); (* myminel *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
_( (* genGetElt *)
    dimCnt := 0;
    l5var29z := exprToGen;
    while (l5var29z@.op = GETELT) do _(
        genFullExpr(l5var29z@.expr2);
        dimCnt := dimCnt + 1;
        getEltInsns[dimCnt] := insnList;
        l5var29z := l5var29z@.expr1;
    _);
    genFullExpr(l5var29z);
    l5ins21z := insnList;
    insnCopy := insnList@;
    copyPtr := ref(insnCopy);
    l5var22z.m := set147z;
    for curDim to dimCnt do
       l5var22z.m := l5var22z.m - getEltInsns[curDim]@.regsused;
    for curDim := dimCnt downto 1 do _(
        l5var26z := insnCopy.typ@.base;
        l5var27z := insnCopy.typ@.range;
        l5var25z := insnCopy.typ@.pck;
        l5var7z := l5var27z@.left;
        l5var8z := l5var26z@.size;
        if not l5var25z then
            insnCopy.ilf6 := insnCopy.ilf6 - l5var8z * l5var7z;
        insnList := getEltInsns[curDim];
        l5ilm28z := insnList@.ilm;
        if (l5ilm28z = ilCONST) then _(
            curVal := insnList@.ilf5;
            curVal.m := curVal.m +  intZero;
            if (curVal.i < l5var7z) or
               (l5var27z@.right < curVal.i) then
                error(29); (* errIndexOutOfBounds *)
            if (l5var25z) then _(
                l5var4z := curVal.i - l5var7z;
                l5var5z := insnCopy.typ@.perword;
                insnCopy.regsused := insnCopy.regsused + [0];
                insnCopy.ilf6 := l5var4z DIV l5var5z + insnCopy.ilf6;
                l5var6z := (l5var5z-1-l5var4z MOD l5var5z) *
                           insnCopy.typ@.pcksize;
                case insnCopy.st of
                st0: insnCopy.shift := l5var6z;
                st1: insnCopy.shift := insnCopy.shift + l5var6z +
                                           insnCopy.typ@.bits - 48;
                st2: error(errUsingVarAfterIndexingPackedArray);
                end; (* case *)
                insnCopy.width := insnCopy.typ@.pcksize;
                insnCopy.st := st1;
            _) (* 6116 *) else _(
                insnCopy.ilf6 := curVal.i  * l5var26z@.size +
                                  insnCopy.ilf6;
            _)
        _) else _( (* 6123*)
            if (checkBounds) then _(
                l5var24z := typeCheck(l5var27z, insnList@.typ);
                if (rangeMismatch) then
                    genCheckBounds(l5var27z);
            _);
            if (l5var8z <> 1) then _(
                prepLoad;
                if (l5var27z@.base = integerType) then _(
                    l5var4z := KYTA+64;
                _) else _(
                    l5var4z := KYTA+64-40;
                _);
                addToInsnList(insnCopy.typ@.perword);
                insnList@.next@.mode := 1;
                if (l5var7z >= 0) then
                    addToInsnList(l5var4z)
                else
                    addToInsnList(macro + mcMULTI);
           _);
           if (l5ilm28z = il3) or
              (l5ilm28z = il1) and
              (insnList@.st <> st0) then
               prepLoad;
           l5var23z.m := insnCopy.regsused + insnList@.regsused;
           if (not l5var25z) then _(
               if (insnCopy.ilf7 = 18) then _(
                    if (insnList@.ilm = il2) then _(
                        insnCopy.ilf7 := 15;
                    _) else _( (* 6200 *)
                        insnCopy.ilf7 := 16;
                        curInsnTemplate := insnTemp[WTC];
                        prepLoad;
                        curInsnTemplate := insnTemp[XTA];
                    _); (* 6205 *)
                    insnCopy.next := insnList@.next;
                    insnCopy.next2 := insnList@.next2;
                _) else _( (* 6211 *)
                    if (insnCopy.ilf7 >= 15) then _(
                        l5var1z :=  myminel(l5var22z.m);
                        if (0 >= l5var1z) then _(
                            l5var1z := myminel(set147z - insnCopy.regsused);
                            if (0 >= l5var1z) then
                                l5var1z := 9;
                        _);
                        saved := insnList;
                        insnList := copyPtr;
                        l5var23z.m := l5var23z.m + [l5var1z];
                        if (insnCopy.ilf7 = 15) then _(
                            addToInsnList(insnTemp[ATI] + l5var1z);
                        _) else _(
                            addToInsnList(indexreg[l5var1z] + insnTemp[VTM]);
                        _);
                        insnCopy.ilf7 := l5var1z;
                        insnCopy.regsused := insnCopy.regsused + [l5var1z];
                        insnList := saved;
                    _) else _(
                            l5var1z := insnCopy.ilf7;
                    _); (* 6251 *)
                    if (l5var1z IN insnList@.regsused) then _(
                         P4606;
                         insnList@.next@.next := insnCopy.next2;
                         insnCopy.next2 := insnList@.next2;
                         insnList := copyPtr;
                         addInsnAndOffset(macro+mcADDSTK2REG, l5var1z);
                    _) else _(
                         if (insnList@.ilm = il2) then _(
                             addInsnAndOffset(macro+mcADDACC2REG, l5var1z);
                         _) else _(
                             curInsnTemplate := insnTemp[WTC];
                             prepLoad;
                             curInsnTemplate := insnTemp[XTA];
                             addToInsnList(indexreg[l5var1z] + insnTemp[UTM]);
                         _);
                         insnCopy.next@.next := insnList@.next2;
                         insnCopy.next := insnList@.next;
                     _)
                _); (* 6305 *)
           _) else _( (* 6306 *)
                if (insnCopy.st = st0) then _(
                    prepLoad;
                    if (l5var7z <> 0) then _(
                        curVal.i := 0 - l5var7z;
                        if (not typeCheck(insnList@.typ, integerType)) then
                            curVal.m := curVal.m - intZero;
                        addToInsnList(KADD+I8 + getFCSToffset);
                        insnList@.next@.mode := 1;
                    _);
                    l5var24z := 0 in insnCopy.regsused;
                    if (l5var24z) then
                        addToInsnList(macro + mcPUSH);
                    saved := insnList;
                    insnList := copyPtr;
                    P4621(14);
                    if (l5var24z) then
                        addToInsnList(macro + mcPOP);
                    l5var23z.m := l5var23z.m + [0, 10, 11, 13, 14];
                    insnCopy.st := st2;
                    insnCopy.ilf6 := 0;
                    insnCopy.ilf5.i := 0;
                    insnCopy.width := insnCopy.typ@.pcksize;
                    curVal.i := insnCopy.width;
                    if (curVal.i = 24) then
                        curVal.i := 7;
                    curVal := curVal;besm(ASN64-24);curVal:=;
                    addToInsnList(allocSymtab(  (* P/00C *)
                        helperNames[76] + curVal.m)+(KVTM+I11));
                    insnCopy.ilf7 := 16;
                    insnCopy.shift := 0;
                    saved@.next@.next := insnCopy.next2;
                    insnCopy.next2 := saved@.next2;
                _) else _(
                    error(errUsingVarAfterIndexingPackedArray);
                _)
            _); (* 6403 *)
            insnCopy.regsused := l5var23z.m;
        _);
        insnCopy.typ := l5var26z;
    _); (* 6406 *)
    insnList := l5ins21z;
    insnList@ := insnCopy;
_); (* genGetElt *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure genEntry;
var
    l5exp1z, l5exp2z: eptr;
    l5idr3z, l5idr4z, l5idr5z, l5idr6z: irptr;
    l5bool7z, l5bool8z, l5bool9z, l5bool10z, l5bool11z: boolean;
    l5var12z, l5var13z, l5var14z: word;
    l5var15z: integer;
    l5var16z, l5var17z, l5var18z, l5var19z: word;
    l5inl20z: @insnltyp;
    l5op21z: operator; l5idc22z: idclass;
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function allocGlobalObject(l6arg1z: irptr): integer;
_(
    if (l6arg1z@.pos = 0) then _(
        if (l6arg1z@.flags * [20, 21] <> []) then _(
            curVal := l6arg1z@.id;
            curVal.m := makeNameWithStars(true);
            l6arg1z@.pos := allocExtSymbol(extSymMask);
        _) else _(
            l6arg1z@.pos := symTabPos;
            putToSymTab([]);
        _)
    _);
    allocGlobalObject := l6arg1z@.pos;
_); (* allocGlobalObject *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure traceEntry(isEntry: boolean);
_(
    if not (debugEntry in optSflags.m) then
        exit;
    curVal := l5idr5z@.id;
    addToInsnList(KVTM+I10 + addCurValToFCST);
    if (isEntry) then
        addToInsnList(KVTM+I11 + lineCnt);
    addToInsnList(getHelperProc(ord(isEntry) * 22 + 57)); (* P/C(E|I) *)
_); (* traceEntry *)
%
_( (* genEntry *)
    l5exp1z := exprToGen@.expr1;
    l5idr5z := exprToGen@.id2;
    l5bool7z := (l5idr5z@.typ = NIL);
    l5bool9z := (l5idr5z@.list = NIL);
    if (l5bool7z) then
        l5var13z.i := 3 else l5var13z.i := 4;
    l5var12z.m := l5idr5z@.flags;
    l5bool10z := (21 in l5var12z.m);
    l5bool11z := (24 in l5var12z.m);
    if (l5bool9z) then _(
        l5var14z.i := F3307(l5idr5z);
        l5idr6z := l5idr5z@.argList;
    _) else _(
        l5var13z.i := l5var13z.i + 2;
    _);
    new(insnList);
    insnList@.next2 := NIL;
    insnList@.next := NIL;
    insnList@.typ := l5idr5z@.typ;
    insnList@.regsused := (l5idr5z@.flags + [7:15]) * [0:8, 10:15];
    insnList@.ilm := il2;
    if (l5bool10z) then _(
        l5bool8z := not l5bool7z;
        if (checkFortran) then _(
            addToInsnList(getHelperProc(92)); (* "P/MF" *)
        _)
    _) else _(
        l5bool8z := true;
        if (not l5bool9z) and (l5exp1z <> NIL)
            or (l5bool9z) and (l5var14z.i >= 2) then _(
            addToInsnList(KUTM+SP + l5var13z.i);
        _);
    _);
    l5var14z.i := 0;
(loop)
    while l5exp1z <> NIL do _( (* 6574 *)
        l5exp2z := l5exp1z@.expr2;
        l5exp1z := l5exp1z@.expr1;
        l5op21z := l5exp2z@.op;
        l5var14z.i := l5var14z.i + 1;
        l5inl20z := insnList;
        if (l5op21z = PCALL) or (l5op21z = FCALL) then _(
            l5idr4z := l5exp2z@.id2;
            new(insnList);
            insnList@.next2 := NIL;
            insnList@.next := NIL;
            insnList@.regsused := [];
            set145z := set145z + l5idr4z@.flags;
            if (l5idr4z@.list <> NIL) then _(
                addToInsnList(l5idr4z@.offset + insnTemp[XTA] +
                              l5idr4z@.value);
                if (l5bool10z) then
                    addToInsnList(getHelperProc(19)); (* "P/EA" *)
            _) else
(a)         _( (* 6636 *)
                if (l5idr4z@.value = 0) then _(
                    if (l5bool10z) and (21 in l5idr4z@.flags) then _(
                        addToInsnList(allocGlobalObject(l5idr4z) +
                                      (KVTM+I14));
                        addToInsnList(KITA+14);
                        exit a;
                    _) else _( (* 6651 *)
                        l5var16z.i := 0;
                        formJump(l5var16z.i);
                        padToLeft;
                        l5idr4z@.value := moduleOffset;
                        l5idr3z := l5idr4z@.argList;
                        l5var15z := ord(l5idr4z@.typ <> NIL);
                        l5var17z.i := F3307(l5idr4z);
                        form3Insn(KVTM+I10+ 4+moduleOffset,
                                  KVTM+I9 + l5var15z,
                                  KVTM+I8 + 74001B);
                        formAndAlign(getHelperProc(62)); (* "P/BP" *)
                        l5var15z := l5var17z.i + 2 + l5var15z;
                        form1Insn(KXTA+SP + l5var15z);
                        if ((1) < l5var17z.i) then
                            form1Insn(KUTM+SP + l5var15z)
                        else
                            form1Insn(0);
                        form2Insn(
                            getHelperProc(63(*P/B6*)) + 6437777777300000C,
                            allocGlobalObject(l5idr4z) + KUJ);
                        if (l5idr3z <> NIL) then _(
                            repeat
                                l5idc22z := l5idr3z@.cl;
                                if (l5idc22z = ROUTINEID) and
                                   (l5idr3z@.typ <> NIL) then
                                    l5idc22z := ENUMID;
                                form2Insn(0, ord(l5idc22z));
                                l5idr3z := l5idr3z@.list;
                            until (l5idr4z = l5idr3z);
                        _); (* 6745 *)
                        storeObjWord([]);
                        P0715(0, l5var16z.i);
                    _)
                _); (* 6752 *)
                addToInsnList(KVTM+I14 + l5idr4z@.value);
                if 21 in l5idr4z@.flags then
                    addToInsnList(KITA+14)
                else
                    addToInsnList(getHelperProc(64)); (* "P/PB" *)
            _); (* 6765 *)
            if (l5op21z = PCALL) then
                l5idc22z := ROUTINEID
            else
                l5idc22z := ENUMID;
        _) else _( (* 6772 *)
            genFullExpr(l5exp2z);
            if (insnList@.ilm = il1) then
                l5idc22z := FORMALID
            else
                l5idc22z := VARID;
        _); (* 7001 *)
        if not (not l5bool9z or (l5idc22z <> FORMALID) or
               (l5idr6z@.cl <> VARID)) then
            l5idc22z := VARID;
(loop)      if (l5idc22z = FORMALID) or (l5bool11z) then _(
            P4621(14);
            addToInsnList(KITA+14);
        _) else if (l5idc22z = VARID) then _(
            if (insnList@.typ@.size <> 1) then _(
                l5idc22z := FORMALID;
                goto loop;
            _) else _(
                prepLoad;
            _)
        _); (* 7027 *)
        if not l5bool8z then
            addxToInsnList(macro + mcPUSH);
        l5bool8z := false;
        if (l5inl20z@.next <> NIL) then _(
            l5inl20z@.next@.next := insnList@.next2;
            insnList@.next2 := l5inl20z@.next2;
        _);
        insnList@.regsused := insnList@.regsused + l5inl20z@.regsused;
        if not l5bool9z then _(
            curVal.cl := l5idc22z;
            addToInsnList(KXTS+I8 + getFCSToffset);
        _);
        if l5bool9z and not l5bool11z then
            l5idr6z := l5idr6z@.list;
    _); (* while -> 7061 *)
    traceEntry(true);
    if l5bool10z then _(
        addToInsnList(KNTR+2);
        insnList@.next@.mode := 4;
    _);
    if l5bool9z then _(
        addToInsnList(allocGlobalObject(l5idr5z) + (KVJM+I13));
        if (20 in l5idr5z@.flags) then _(
            l5var17z.i := 1;
        _) else _(
            l5var17z.i := l5idr5z@.offset div 4000000B;
        _) (* 7102 *)
    _) else _( (* 7103 *)
        l5var15z := 0;
        if (l5var14z.i = 0) then _(
            l5var17z.i := l5var13z.i + 1;
        _) else _(
            l5var17z.i := -(2 * l5var14z.i + l5var13z.i);
            l5var15z := 1;
        _); (* 7115 *)
        addInsnAndOffset(macro+16 + l5var15z,
                         getValueOrAllocSymtab(l5var17z.i));
        addToInsnList(l5idr5z@.offset + insnTemp[UTC] + l5idr5z@.value);
        addToInsnList(macro+18);
        l5var17z.i := 1;
    _); (* 7132 *)
    insnList@.next@.mode := 2;
    if (curProcNesting <> l5var17z.i) then _(
        if not l5bool10z then _(
            if (l5var17z.i + 1 = curProcNesting) then _(
                addToInsnList(KMTJ+I7 + curProcNesting);
            _) else _(
                l5var15z := frameRestore[curProcNesting][l5var17z.i];
                if (l5var15z = (0)) then _(
                    curVal.i := 6017T; (* P/ *)
                    l5var19z.i := curProcNesting + 16;
                    besm(ASN64-30);
                    l5var19z := ;
                    l5var18z.i := l5var17z.i + 16;
                    besm(ASN64-24);
                    l5var18z := ;
                    curVal.m := curVal.m + l5var19z.m + l5var18z.m;
                    l5var15z := allocExtSymbol(extSymMask);
                    frameRestore[curProcNesting][l5var17z.i] := l5var15z;
                _);
                addToInsnList(KVJM+I13 + l5var15z);
            _)
        _)
    _); (* 7176 *)
    if not l5bool9z or ([20, 21] * l5var12z.m <> []) then _(
        addToInsnList(KVTM+40074001B);
    _);
    set145z := (set145z + l5var12z.m) * [1:15];
    traceEntry(false);
    if l5bool10z then _(
        if (not checkFortran) then
            addToInsnList(KNTR+7)
        else
            addToInsnList(getHelperProc(93));    (* "P/FM" *)
        insnList@.next@.mode := 2;
    _) else _(
        if not l5bool7z then
            addToInsnList(KXTA+SP + l5var13z.i - 1);
    _); (* 7226 *)
    if not l5bool7z then _(
        insnList@.typ := l5idr5z@.typ;
        insnList@.regsused := insnList@.regsused + [0];
        insnList@.ilm := il2;
        set146z := set146z - l5var12z.m;
    _)
    (* 7237 *)
_); (* genEntry *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure startInsnList(l5arg1z: ilmode);
_(
    new(insnList);
    insnList@.next := NIL;
    insnList@.next2 := NIL;
    insnList@.typ := exprToGen@.typ;
    insnList@.regsused := [];
    insnList@.ilm := l5arg1z;
    if (l5arg1z = ilCONST) then _(
        insnList@.ilf5.i := exprToGen@.num1;
        insnList@.ilf7 := exprToGen@.num2;
    _) else _(
        insnList@.st := st0;
        insnList@.ilf7 := 18;
        insnList@.ilf5.i := curFrameRegTemplate;
        insnList@.ilf6 := exprToGen@.num1;
    _)
_); (* startInsnList *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure genCopy;
var
    size: integer;
_(
    size := insnList@.typ@.size;
    if (size = 1) then _(
        saved := insnList;
        insnList := otherIns;
        prepLoad;
        genOneOp;
        insnList := saved;
        prepStore;
        genOneOp;
    _) else _(
        prepMultiWord;
        genOneOp;
        size := size - 1;
        formAndAlign(KVTM+I13 + getValueOrAllocSymtab(-size));
        work := moduleOffset;
        form2Insn(KUTC+I14 + size, KXTA+I13);
        form3Insn(KUTC+I12 + size, KATX+I13,
                  KVLM+I13 + work);
        set145z := set145z + [12:14];
    _)
_); (* genCopy *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure genConstDiv;
    function PASDIV(r: real): word;
        external;
_(
    curVal := PASDIV(1/arg2Val.i);
    addToInsnList(KMUL+I8 + getFCSToffset);
_); (* genConstDiv *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure genComparison;
label
    7475, 7504, 7514, 7530;
var
    hasEq: boolean;
    l5set2z: bitset;
    mode, size: integer;
_(
    l3int3z := ord(curOP) - ord(NEOP);
    hasEq := odd(l3int3z);
    if (l3int3z = 6) then _(     (* IN *)
        if (arg1Const) then _(
            if (arg2Const) then _(
                insnList@.ilf5.b := (arg1Val.i IN arg2Val.m);
            _) else _(
                l5set2z := [arg1Val.i];
                if (l5set2z = []) then _(
                    insnList@.ilf5.b := false;
                _) else _(
                    insnList := otherIns;
                    prepLoad;
                    curVal.m := l5set2z;
                    addToInsnList(KAAX+I8 + getFCSToffset);
                    insnList@.ilf5.i := 0;
                    insnList@.ilm := il3;
                _)
            _); (* 7412 *)
        _) else _( (* 7413 *)
            saved := insnList;
            insnList := otherIns;
            otherIns := saved;
            nextInsn := 66;      (* P/IN *)
            genHelper;
            insnList@.ilm := il2;
        _)
    _) else _( (* 7423 *)
        if hasEq then
            l3int3z := l3int3z - 1;
        curType := insnList@.typ;
        curVarKind := curType@.k;
        size := curType@.size;
        if (curType = realType) then _(
            if (fuzzReals) then
                work := 0
            else
                work := 1;
        _) else if (curVarKind = kindSet) then
            work := 2
        else if (curVarKind IN [kindScalar, kindRange]) then
            work := 3
        else _(
            work := 4;
        _);
        if (size <> 1) then _(
            prepMultiWord;
            addInsnAndOffset(KVTM+I11, 1 - size);
            addToInsnList(getHelperProc(89 + l3int3z)); (* P/EQ *)
            insnList@.ilm := il2;
            hasEq := not hasEq;
        _) else (* 7471 *) if l3int3z = 0 then _(
            if work = 0 then _(
                nextInsn := 15;         (* P/CP *)
7475:           genHelper;
                insnList@.ilm := il2;
            _) else _( (* 7501 *)
                nextInsn := insnTemp[AEX];
                tryFlip(true);
7504:           insnList@.ilm := il3;
                insnList@.ilf5.i := 0;
            _);
        _) else _( (* 7510 *)
            case work of
            0: _( (*7511*)
                nextInsn := 16;         (* P/AB *)
                goto 7475;
            _);
            1: _( (*7513*)
                mode := 3;
7514:           nextInsn := insnTemp[SUB];
                tryFlip(false);
                insnList@.next@.mode := mode;
                if mode = 3 then _(
                    addToInsnList(KNTR+23B);
                    insnList@.next@.mode := 2;
                _);
                goto 7504;
            _);
            2: _( (*7527*)
                nextInsn := insnTemp[AAX];
7530:           prepLoad;
                addToInsnList(KAEX+ALLONES);
                tryFlip(true);
                goto 7504;
            _);
            3: _( (*7536*)
                mode := 1;
                goto 7514;
            _);
            4: _( (*7540*)
                nextInsn := insnTemp[ARX];
                goto 7530;
            _);
            end; (* case *)
        _); (* 7554 *)
        insnList@.regsused := insnList@.regsused - [16];
        if (hasEq)
            then negateCond;
    _); (* 7562 *)
    (* 7562 *)
_); (* genComparison *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
_( (* genFullExpr *);
    if exprToGen = NIL then
        exit;
7567:
    curOP := exprToGen@.op;
    if (curOP < GETELT) then _(
        genFullExpr(exprToGen@.expr2);
        otherIns := insnList;
        if (curOP = ASSIGNOP) then
            l3bool13z := false;
        genFullExpr(exprToGen@.expr1);
        if (curOP = ASSIGNOP) then
            l3bool13z := true;
        if (insnList@.ilm = ilCONST) then _(
            arg1Const := true;
            arg1Val := insnList@.ilf5;
        _) else
            arg1Const := false;
        if (otherIns@.ilm = ilCONST) then _(
            arg2Const := true;
            arg2Val := otherIns@.ilf5;
        _) else
            arg2Const := false;
        if (curOP IN [NEOP, EQOP, LTOP, GEOP, GTOP, LEOP, INOP]) then _(
            genComparison;
        _) else _( (* 7625 *)
            if arg1Const and arg2Const then _(
                case curOP of
                MUL:        arg1Val.r := arg1Val.r * arg2Val.r;
                RDIVOP:     arg1Val.r := arg1Val.r / arg2Val.r;
                AMPERS:     arg1Val.b := arg1Val.b and arg2Val.b;
                IDIVOP:     arg1Val.i := arg1Val.i DIV arg2Val.i;
                IMODOP:     arg1Val.i := arg1Val.i MOD arg2Val.i;
                PLUSOP:     arg1Val.r := arg1Val.r + arg2Val.r;
                MINUSOP:    arg1Val.r := arg1Val.r - arg2Val.r;
                OROP:       arg1Val.b := arg1Val.b or arg2Val.b:
                IMULOP:     arg1Val.i := arg1Val.i * arg2Val.i;
                SETAND:     arg1Val.m := arg1Val.m * arg2Val.m;
                SETXOR:     arg1Val.m := arg1Val.m MOD arg2Val.m;
                INTPLUS:    arg1Val.i := arg1Val.i + arg2Val.i;
                INTMINUS:   arg1Val.i := arg1Val.i - arg2Val.i;
                SETOR:      arg1Val.m := arg1Val.m + arg2Val.m;
                IDIVROP:    arg1Val.r := arg1Val.i / arg2Val.i;
                SETSUB:
                    goto 10075;
                NEOP, EQOP, LTOP, GEOP, GTOP, LEOP, INOP,
                badop27, badop30, badop31, MKRANGE, ASSIGNOP:
                    error(200);
                end; (* case 7750 *)
                insnList@.ilf5 := arg1Val;
            _) else _( (*7752*)
                l3int3z := opToMode[curOP];
                flags := opFlags[curOP];
                nextInsn := opToInsn[curOP];
                case flags of
                opfCOMM:
7760:               tryFlip(curOP in [MUL, PLUSOP, SETAND, INTPLUS]);
                opfHELP:
                    genHelper;
                opfASSN: _(
                    genCopy;
                    exit
                _);
                opfAND: _(
                    genBoolAnd;
                    exit
                _);
                opfOR: _(
                    negateCond;
                    saved := insnList;
                    insnList := otherIns;
                    negateCond;
                    otherIns := insnList;
                    insnList := saved;
                    genBoolAnd;
                    negateCond;
                    exit
                _);
                opfMOD:
                    if (arg2Const) then _(
                        prepLoad;
                        if card(arg2Val.m) = 4 then _(
                            curVal.m := [0,1,3,minel(arg2Val.m-intZero)+1..47];
                            addToInsnList(KAAX+I8 +getFCSToffset);
                            l3int3z := 0;
                        _) else _( (* 10016 *)
                            addToInsnList(macro + mcPUSH);
                            genConstDiv;
                            insnList@.next@.mode := 1;
                            curVal.m := arg2Val.m - [1, 3];
                            addToInsnList(KMUL+I8 + getFCSToffset);
                            addToInsnList(KYTA+64);
                            addToInsnList(KRSUB+SP);
                            l3int3z := 1;
                        _) (* 10036 *)
                    _) else _( (* 10037 *)
                        genHelper;
                    _);
                opfDIV: _(
                    if arg2Const then _(
                        prepLoad;
                        genConstDiv;
                        l3int3z := 1;
                    _) else
                        genHelper;
                _);
                opfMULMSK: _(
                    if (arg1Const) then _(
                        insnList@.ilf5.m := arg1Val.m MOD [1, 3];
                    _) else _(
                        if (arg2Const) then _(
                            otherIns@.ilf5.m := arg2Val.m MOD [1, 3];
                        _) else _(
                            prepLoad;
                            addToInsnList(KAEX+MULTMASK);
                        _)
                    _);
                    tryFlip(true);
                    insnList@.next@.mode := 1;
                    if (fixMult) then
                        addToInsnList(macro + mcMULTI)
                    else
                        addToInsnList(KYTA+64);
                _);
                opfINV: _(
10075:              saved := insnList;
                    insnList := otherIns;
                    otherIns := saved;
                    prepLoad;
                    addToInsnList(KAEX+ALLONES);
                    goto 7760
                _)
                end; (* case 10122 *)
10122:          insnList@.next@.mode := l3int3z;
            _)
        _)
    _) else _( (* 10125 *)
        if (FILEPTR >= curOP) then _(
            if (curOP = GETVAR) then _(
                new(insnList);
                curIdRec := exprToGen@.id1;
                with insnList@ do _(
                    next := NIL;
                    next2 := NIL;
                    regsused := [];
                    ilm := il1;
                    ilf5.i := curIdRec@.offset;
                    ilf6 := curIdRec@.high.i;
                    st := st0;
                    ilf7 := 18;
                _);
                if (curIdRec@.cl = FORMALID) then _(
                    genDeref;
                _) else if (curIdRec@.cl = ROUTINEID) then _(
                    insnList@.ilf6 := 3;
                    insnList@.ilf5.i := (insnList@.ilf5.i + frameRegTemplate);
                _) else if (insnList@.ilf6 >= 74000B) then _(
                    addToInsnList(insnTemp[UTC] + insnList@.ilf6);
                    insnList@.ilf6 := 0;
                    insnList@.ilf7 := 17;
                    insnList@.ilf5.i := 0;
                _)
            _) else (* 10171 *)
            if (curOP = GETFIELD) then _(
                genFullExpr(exprToGen@.expr1);
                curIdRec := exprToGen@.id2;
                with insnList@ do _(
                    ilf6 := ilf6 + curIdRec@.offset;
                    if (curIdRec@.pckfield) then _(
                        case st of
                        st0:
                            shift := curIdRec@.shift;
                        st1: _(
                            shift := shift + curIdRec@.shift;
                            if not (S6 IN optSflags.m) then
                                shift := shift +
                                           curIdRec@.uptype@.bits - 48;
                        _);
                        st2:
                            if (not l3bool13z) then
                                error(errUsingVarAfterIndexingPackedArray)
                            else _(
                                P5155;
                                insnList@.shift := curIdRec@.shift;
                            _)
                        end; (* 10235*)
                        insnList@.width := curIdRec@.width;
                        insnList@.st := st1;
                        insnList@.regsused := insnList@.regsused + [0];
                    _)
                _);
            _) else (* 10244 *)
            if (curOP = GETELT) then
                genGetElt
            else
            if (curOP = DEREF) or (curOP = FILEPTR) then _(
                genFullExpr(exprToGen@.expr1);
                genDeref;
            _) else
            if (curOP = op36) then _(
                startInsnList(il1);
            _) else
            if (curOP = op37) then _(
                startInsnList(il1);
                genDeref;
            _) else
            if (curOP = GETENUM) then
                startInsnList(ilCONST)
        _) else (* 10272 *)
        if (curOP = ALNUM) then
            genEntry
        else if (curOP IN [BOUNDS..RNEGOP]) then _(
            genFullExpr(exprToGen@.expr1);
            if (insnList@.ilm = ilCONST) then _(
                arg1Val := insnList@.ilf5;
                case curOP of
                BOUNDS: _(
                    arg2Val.m := [0,1,3] + arg1Val.m;
                    with exprToGen@.typ2@ do _(
                        if (arg2Val.i < left) or
                           (right < arg2Val.i) then
                            error(errNeedOtherTypesOfOperands)
                    _)
                _);
                TOREAL: arg1Val.r := arg1Val.i;
                NOTOP:  arg1Val.b := not arg1Val.b;
                RNEGOP: arg1Val.r := -arg1Val.r;
                INEGOP: arg1Val.i := -arg1Val.i;
                end; (* case 10345 *)
                insnList@.ilf5 := arg1Val;
            _) else (* 10347 *)
            if (curOP = NOTOP) then _(
                negateCond;
            _) else _(
                prepLoad;
                if (curOP = BOUNDS) then _(
                    if (checkBounds) then
                        genCheckBounds(exprToGen@.typ2);
                _) else if (curOP = TOREAL) then _(
                    addToInsnList(insnTemp[AVX]);
                    l3int3z := 3;
                    goto 10122;
                _) else _(
                    addToInsnList(KAVX+MINUS1);
                    if (curOP = RNEGOP) then
                        l3int3z := 3
                    else
                        l3int3z := 1;
                    goto 10122;
                _)
            _)
        _) else (* 10376 *)
        if (curOP = STANDPROC) then _(
            genFullExpr(exprToGen@.expr1);
            work := exprToGen@.num2;
            if (100 < work) then _(
                prepLoad;
                addToInsnList(getHelperProc(work - 100));
            _) else _(
                if (insnList@.ilm = ilCONST) then _(
                    arg1Const := true;
                    arg1Val := insnList@.ilf5;
                _) else
                    arg1Const := false;
                arg2Const := (insnList@.typ = realType);
                if (arg1Const) then _(
                    case work of
                    fnSQRT:  arg1Val.r := sqrt(arg1Val.r);
                    fnSIN:   arg1Val.r := sin(arg1Val.r);
                    fnCOS:   arg1Val.r := cos(arg1Val.r);
                    fnATAN:  arg1Val.r := arctan(arg1Val.r);
                    fnASIN:  arg1Val.r := arcsin(arg1Val.r);
                    fnLN:    arg1Val.r := ln(arg1Val.r);
                    fnEXP:   arg1Val.r := exp(arg1Val.r);
                    fnABSR:  arg1Val.r := abs(arg1Val.r);
                    fnTRUNC: arg1Val.i := trunc(arg1Val.r);
                    fnODD:   arg1Val.b := odd(arg1Val.i);
                    fnORD:   arg1Val.i := ord(arg1Val.c);
                    fnCHR:   arg1Val.c := chr(arg1Val.i);
                    fnSUCC:  arg1Val.c := succ(arg1Val.c);
                    fnPRED:  arg1Val.c := pred(arg1Val.c);
                    fnPTR:   arg1Val.c := chr(arg1Val.i);
                    fnSQRR:  arg1Val.r := arg1Val.r*arg1Val.r;
                    fnROUND: arg1Val.i := round(arg1Val.r);
                    fnCARD:  arg1Val.i := card(arg1Val.m);
                    fnMINEL: arg1Val.i := minel(arg1Val.m);
                    fnABSI:  arg1Val.i := abs(arg1Val.i);
                    fnSQRI:  arg1Val.i := arg1Val.i*arg1Val.i;
                    fnEOF,
                    fnREF,
                    fnEOLN:
                        error(201);
                    end; (* 10546 *)
                    insnList@.ilf5 := arg1Val;
                _) else (* 10550 *)
                if (work >= 14) and (16 >= work) then _(
                    if (work = 15) then _(
                        P4621(14);
                        addToInsnList(KITA+14);
                    _) else _(
                        P4621(12);
                        addToInsnList(getHelperProc(work - 6));
                    _);
                    with insnList@ do _(
                        ilm := il2;
                        regsused := regsused + [0];
                    _)
                _) else _(
                    prepLoad;
                    if (work = 8) then _(
                        l3int3z := 2;
                        addToInsnList(getHelperProc(58)); (*"P/TR"*)
                        goto 10122;
                    _);
                    if (work IN [0, 1, 2, 3, 4, 5, 6,
                                      9, 10, 11, 12, 19, 21]) then _(
                        l3int3z := 0;
                    _) else if (work IN [7, 17]) then
                        l3int3z := 3
                    else _(
                        l3int3z := 1;
                    _);
                    addToInsnList(funcInsn[work]);
                    goto 10122;
                _)
            _)
        _) else _( (* 10621 *)
            if (curOP = NOOP) then _(
                curVal := exprToGen@.val;
                if (curVal.i IN set146z) then _(
                    new(insnList);
                    with insnList@ do _(
                        typ := exprToGen@.expr2@.typ;
                        next := NIL;
                        next2 := ;
                        regsused := [];
                        ilm := il1;
                        ilf7 := 18;
                        ilf5.i := indexreg[curVal.i];
                        ilf6 := 0;
                        st := st0;
                    _)
                _) else _(
                    curVal.i := 14;
                    exprToGen@.val := curVal;
                    exprToGen := exprToGen@.expr2;
                    goto 7567;
                _);
                exit
            _) else _(
                error(220);
            _)
        _);
    _); (* 10654 *)
    insnList@.typ := exprToGen@.typ;
    (* 10656 *)
_); (* genFullExpr *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure formFileInit;
var l4exf1z: @extfilerec;
    l4var2z: tptr;
    l4var3z: irptr;
    l4int4z, l4int5z: integer;
_(
    if (S5 IN optSflags.m) then _(
        formAndAlign(KUJ+I13);
        exit
    _);
    form2Insn(KITS+13, KATX+SP);
    while (curExpr <> NIL) do _(
        l4exf1z := ptr(ord(curExpr@.typ));
        l4var3z := curExpr@.id2;
        l4int4z := l4var3z@.value;
        l4var2z := l4var3z@.typ@.base;
        l4int5z := l4var3z@.typ@.elsize;
        if (l4int4z < 74000B) then _(
            form1Insn(getValueOrAllocSymtab(l4int4z) +
                      insnTemp[UTC] + I7);
            l4int4z := 0;
        _);
        form3Insn(KVTM+I12 + l4int4z, KVTM+I10 + fileBufSize,
                  KVTM+I9 + l4int5z);
        form1Insn(KVTM+I11 + l4var2z@.size);
        if (l4exf1z = NIL) then _(
            form1Insn(insnTemp[XTA]);
        _) else _(
            curVal.i := l4exf1z@.location;
            if (curVal.i = 512) then
                curVal.i := l4exf1z@.offset;
            form1Insn(KXTA+I8 + getFCSToffset);
        _);
        formAndAlign(getHelperProc(69)); (*"P/CO"*)
        curVal := l4var3z@.id;
        form2Insn(KXTA+I8+getFCSToffset, KATX+I12+26);
        if (l4int5z <> 0) and
           typeCheck(l4var2z, integerType) then
            form2Insn(KXTA+ZERO, KATX+I12+25);
        curExpr := curExpr@.expr1;
    _);
    form1Insn(getHelperProc(70)(*"P/IT"*) + (-I13-100000B));
    padToLeft;
_); (* formFileInit *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
_( (* formOperator *)
    l3bool13z := true;
    if (errors and (l3arg1z <> SETREG)) or (curExpr = NIL) then
        exit;
    if not (l3arg1z IN [BINOP, STOREELT, LOADINT, gen14, PCKUNPCK]) then
        genFullExpr(curExpr);
    case l3arg1z of
    gen7: genOneOp;
    SETREG: _(
        with insnList@ do _(
            l3int3z := insnCount;
            new(l3var5z);
            l3var5z@.expr1 := expr63z;
            expr63z := l3var5z;
            l3var5z@.op := NOOP;
            case st of
            st0: _(
                if (l3int3z = 0) then _(
                    l3int2z := 14;
                _) else _(
                    l3var10z.m := set148z * set147z;
                    if (l3var10z.m <> []) then _(
                        l3int2z := minel(l3var10z.m);
                    _) else _(
                        l3int2z := 14;
                    _);
                    if (l3int3z <> 1) then _(
                        P4621(l3int2z);
                        addToInsnList(KITA + l3int2z);
                        mkTempVar(op37);
                    _) else if (l3int2z <> 14) then _(
                        P4621(l3int2z);
                        genOneOp;
                    _);
                    l3var11z.m := [l3int2z] - [14];
                    set145z := set145z - l3var11z.m;
                    set147z := set147z - l3var11z.m;
                    set146z := set146z + l3var11z.m;
                _);
                curVal.i := l3int2z;
                l3var5z@.val := curVal;
            _);
            st1: _(
                curVal.i := 14;
                l3var5z@.val := curVal;
            _);
            st2:
                error(errVarTooComplex);
            end; (* case *)
        _); (* with *)
        l3var5z@.expr2 := curExpr;
    _); (* SETREG *)
    LOOPLIMIT: _(
        prepLoad;
        if (insnCount > 1) then
            mkTempVar(op36)
    _);
    STORE: _(
        prepStore;
        genOneOp
    _);
    BINOP: _(
        curInsnTemplate := curVal.i;
        formOperator(LOAD);
        curInsnTemplate := insnTemp[XTA];
    _);
    gen5: _(
        if (insnList@.st <> st0) then
            error(errVarTooComplex);
        P4621(9);
        genOneOp;
    _);
    STOREELT: _(
        l3int1z := curVal.i;
        genFullExpr(curExpr);
        prepLoad;
        if (9 IN insnList@.regsused) then
            error(errVarTooComplex);
        genOneOp;
        form1Insn(KATX+I9 + l3int1z);
    _);
    gen8: _(
        P4621(12);
        genOneOp
    _);
    LOADINT: _(
        curVal.m := curVal.m + intZero;
        form1Insn(KXTA+I8 + getFCSToffset);
    _);
    PUSHARG: _(
        prepLoad;
        addxToInsnList(macro + mcPUSH);
        genOneOp;
    _);
    gen11, gen12: _(
        P4621(11);
        if (l3arg1z = gen12) then
            addxToInsnList(macro + mcPUSH);
        genOneOp;
        set145z := set145z + [12];
    _);
    FILEACCESS: _(
        P4621(12);
        genOneOp;
        formAndAlign(jumpTarget);
    _);
    gen14:
        formFileInit;
    LOAD: _(
        prepLoad;
        genOneOp
    _);
    gen15:
        with insnList@ do _(
            l3bool9z := jumpTarget = 0;
            l3int3z := jumpTarget;
            if ilm = ilCONST then _(
                if ilf5.b then 
                    jumpTarget := 0
                else if l3bool9z then
                    formJump(jumpTarget)
                else
                    form1Insn(insnTemp[UJ] + jumpTarget);
            _) else _(
                l3var8z.b := 16 in insnList@.regsused;
                if (insnList@.ilm = il3) and
                   (insnList@.ilf5.i <> 0) then _(
                    genOneOp;
                    if (l3var8z.b) then _(
                        if (l3bool9z) then
                            formJump(l3int3z)
                        else
                            form1Insn(insnTemp[UJ] + l3int3z);
                        P0715(0, jumpTarget);
                        jumpTarget := l3int3z;
                    _) else if not l3bool9z then _(
                        if (not putLeft) then
                            padToLeft;
                        P0715(l3int3z, jumpTarget);
                    _);
                _) else _(
                    if (insnList@.ilm = il1) then _(
                        bool49z := false;
                        prepLoad;
                        bool49z := true;
                    _);
                    genOneOp;
                    if (l3var8z.b) then
                        nextInsn := insnTemp[U1A]
                    else
                        nextInsn := insnTemp[UZA];
                    if (l3bool9z) then _(
                        jumpType := nextInsn;
                        formJump(l3int3z);
                        jumpType := insnTemp[UJ];
                        jumpTarget := l3int3z;
                    _) else _(
                        form1Insn(nextInsn + l3int3z);
                    _)
                _)
            _)
        _); (* gen15 *)
    PCKUNPCK: _(
        l3var5z := curExpr;
        curExpr := curExpr@.expr1;
        formOperator(gen11);
        genFullExpr(l3var5z@.expr2);
        if (11 IN insnList@.regsused) then
            error(44); (* errIncorrectUsageOfStandProcOrFunc *)
        P4621(12);
        genOneOp;
        arg1Type := l3var5z@.expr2@.typ;
        with arg1Type@.range@ do
            l3int3z := right - left + 1;
        form2Insn((KVTM+I14) + l3int3z,
                  (KVTM+I10+64) - arg1Type@.pcksize);
        l3int3z := ord(l3var5z@.typ);
        l3int1z := arg1Type@.perword;
        if (l3int3z = 72) then          (* P/KC *)
            l3int1z := 1 - l3int1z;
        form1Insn(getValueOrAllocSymtab(l3int1z) + (KVTM+I9));
        if typeCheck(curExpr@.typ, integerType) then _(
            l3int1z := KXTA+ZERO;
        _) else _(
            l3int1z := insnTemp[XTA];
        _);
        form1Insn(l3int1z);
        formAndAlign(getHelperProc(l3int3z));
   _);
   LITINSN: _(
        with insnList@ do _(
            if (ilm <> ilCONST) then
                error(errNoConstant);
            if (insnList@.typ@.size <> 1) then
                error(errConstOfOtherTypeNeeded);
            curVal := insnList@.ilf5;
        _)
    _);
    end; (* case *)
_); (* formOperator *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure parseTypeRef(var newtype: tptr; skipTarget: setofsys);
label
    12247, 12366, 12476, 12760, 13020;
type
    pair = record
            first, second: integer
        end;
    pair7 = array [1..7] of pair;
    caserec = record
            size, count: integer;
            pairs: pair7;
        end;
var
    isPacked: boolean;
    cond: boolean;
    cases: caserec;
    leftBound, rightBound: word;
    numBits, l3int22z, span: integer;
    curEnum, curField: irptr;
    l3typ26z, nestedType, tempType, curType: tptr;
    l3unu30z: word;
    l3idr31z: irptr;
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure definePtrType(toType: tptr);
_(
    new(curType = 4);
    curType@ := [1, 15, kindPtr, toType];
    new(curEnum = 5);
    curEnum@ := [curIdent, lineCnt, typelist, curType, TYPEID];
    typelist := curEnum;
_); (* definePtrType *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure parseRecordDecl(rectype: tptr; isOuterDecl: boolean);
var
    l4typ1z, selType, l4var3z, l4var4z, l4var5z: tptr;
    l4var6z: irptr;
    l4var7z, l4var8z: word;
    l4var9z: integer;
    cases1, cases2: caserec;
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure addFieldToHash;
_(
    curEnum@ := [curIdent, , typeHashTabBase[bucket], ,
                    FIELDID, NIL, curType, isPacked];
    typeHashTabBase[bucket] := curEnum;
_); (* addFieldToHash *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure packFields;
label
    11523, 11622;
var
    l5var1z, pairIdx, l5var3z, l5var4z, l5var5z: integer;
    l5var6z: @pair;
_(
    parseTypeRef(selType, skipTarget + [CASESY]);
    if (curType@.ptr2 = NIL) then _(
        curType@.ptr2 := curField;
    _) else _(
        l3idr31z@.list := curField;
    _);
    cond := isFileType(selType);
    if (not isOuterDecl) and cond then
        error(errTypeMustNotBeFile);
    curType@.flag := cond or curType@.flag;
    l3idr31z := curEnum;
    repeat
        curField@.typ := selType;
(q)     if (isPacked) then _(
            l5var1z := selType@.bits;
            curField@.width := l5var1z;
            if (l5var1z <> 48) then _(
                for pairIdx to cases.count do
11523:          _(
                    l5var6z := ref(cases.pairs[pairIdx]);
                    if (l5var6z@.first >= l5var1z) then _(
                        curField@.shift := 48 - l5var6z@.first;
                        curField@.offset := l5var6z@.second;
                        if not (S6 IN optSflags.m) then
                            curField@.shift := 48 - curField@.width -
                                                  curField@.shift;
                        l5var6z@.first := l5var6z@.first - l5var1z;
                        if l5var6z@.first = 0 then _(
                            cases.pairs[pairIdx] :=
                                cases.pairs[cases.count];
                            cases.count := cases.count - 1;
                        _); (* 11562 *)
                        goto 11622;
                    _)
                _); (* 11564 *)
                if (cases.count <> 7) then _(
                    cases.count := cases.count + 1;
                    pairIdx := cases.count;
                _) else _(
                    l5var3z := 48;
                    for l5var4z to 7 do _(
                        l5var5z := cases.pairs[l5var4z].first;
                        if (l5var5z < l5var3z) then _(
                            l5var3z := l5var5z;
                            pairIdx := l5var4z;
                        _)
                    _); (* for *)
                _); (* 11606 *)
                cases.pairs[pairIdx] := [48, cases.size];
                cases.size := cases.size + 1;
                goto 11523;
            _)
        _); (* 11615 *)
        curField@.pckfield := false;
        curField@.offset := cases.size;
        cases.size := cases.size + selType@.size;
11622:
        if (PASINFOR.listMode = 3) then _(
            write(' ':16);
            if (curField@.pckfield) then
                write('PACKED');
            write(' FIELD ');
            printTextWord(curField@.id);
            write('.OFFSET=', curField@.offset:5 oct, 'B');
            if (curField@.pckfield) then _(
                write('.<<=SHIFT=', curField@.shift:2,
                      '. WIDTH=', curField@.width:2, ' BITS');
            _) else _(
                write('.WORDS=', selType@.size:0);
            _);
            writeLN;
        _);
        cond := (curField = curEnum);
        curField := curField@.list;
    until cond;
    (* 11674 *)
_); (* packFields *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
_( (* parseRecordDecl *)
    int93z := 3;
    inSymbol;
    (*11702*)
    while (SY = IDENT) do _(
        l4var6z := NIL;
        repeat
            if (SY <> IDENT) then _(
                error(errNoIdent);
            _) else _(
                if (hashTravPtr <> NIL) then
                    error(errIdentAlreadyDefined);
                new(curEnum = 10);
                addFieldToHash;
                if (l4var6z = NIL) then _(
                    curField := curEnum;
                _) else _(
                    l4var6z@.list := curEnum;
                _);
                l4var6z := curEnum;
                int93z := 3;
                inSymbol;
            _);
            cond := (SY <> COMMA);
            if (not cond) then _(
                int93z := 3;
                inSymbol;
            _)
        until cond;
        checkSymAndRead(COLON);
        packFields;
        if (SY = SEMICOLON) then _(
            int93z := 3;
            inSymbol;
        _)
    _); (*11752*)
    if (SY = CASESY) then _(
        int93z := 3;
        inSymbol;
        selType := integerType;
(identif)
        if (SY <> IDENT) then _(
            error(3);
            skip(skipTarget + [OFSY]);
        _) else _( (* 11766 *)
            l4var8z := curIdent;
            l4var9z := bucket;
            curEnum := hashTravPtr;
            inSymbol;
            if (SY = COLON) then _(
                if (curEnum <> NIL) then
                    error(errIdentAlreadyDefined);
                new(curEnum = 10);
                curIdent := l4var8z;
                bucket := l4var9z;
                addFieldToHash;
                inSymbol;
                curField := curEnum;
                packFields;
            _) else _(
                curEnum := symHashTabBase[l4var9z];
                while (curEnum <> NIL) do _(
                    if (curEnum@.id <> l4var8z) then _(
                        curEnum := curEnum@.next;
                    _) else _(
                        if (curEnum@.cl <> TYPEID) then _(
                            error(errNotAType);
                            selType := integerType;
                        _) else _(
                            selType := curEnum@.typ;
                        _);
                        exit identif;
                    _);
                _);
                error(errNotDefined)
            _);
        _); (* 12035 *)
        if (selType@.k = kindRange) then
            selType := selType@.base;
        checkSymAndRead(OFSY);
        cases1 := cases;
        cases2 := cases;
        l4typ1z := NIL;
        repeat
            l4var3z := NIL;
            repeat
                parseLiteral(l4var4z, l4var7z, false);
                if (l4var4z = NIL) then
                    error(errNoConstant)
                else if (not typeCheck(l4var4z, selType)) then
                    error(errConstOfOtherTypeNeeded);
                new(l4var5z = 7);
                l4var5z@ := [cases.size, 48, kindCases,
                                    l4var7z, NIL, NIL, NIL];
                if (l4var3z = NIL) then _(
                    tempType := l4var5z;
                _) else _(
                    l4var3z@.r6 := l4var5z;
                _);
                l4var3z := l4var5z;
                inSymbol;
                cond := (SY <> COMMA);
                if (not cond) then
                    inSymbol;
            until cond;
            if (l4typ1z = NIL) then _(
                if (curType@.base = NIL) then _(
                    curType@.base := tempType;
                _) else _(
                    rectype@.first := tempType;
                _)
            _) else _(
                l4typ1z@.next := tempType;
            _);
            l4typ1z := tempType;
            checkSymAndRead(COLON);
            if (SY <> LPAREN) then
                requiredSymErr(LPAREN);
            parseRecordDecl(tempType, false);
            if (cases2.size < cases.size) or
               isPacked and (cases.size = 1) and (cases2.size = 1) and
                (cases.count = 1) and (cases2.count = 1) and
                (cases.pairs[1].first < cases2.pairs[1].first) then _(
                cases2 := cases;
            _); (* 12201 *)
            cases := cases1;
            checkSymAndRead(RPAREN);
            cond := SY <> SEMICOLON;
            if (not cond) then
                inSymbol;
            if (SY = ENDSY) then
                cond := true;
        until cond;
        cases := cases2;
    _); (* 12232 *)
    rectype@.size := cases.size;
    if isPacked and (cases.size = 1) and (cases.count = 1) then _(
        rectype@.bits := 48 - cases.pairs[1].first;
    _)
    (* 12242 *)
_); (* parseRecordDecl*)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
_( (* parseTypeRef *)
    isPacked := false;
12247:
    if (SY = LPAREN) then _(
        span := 0;
        int93z := 0;
        inSymbol;
        curField := NIL;
        new(curType = 6);
        while (SY = IDENT) do _(
            if (isDefined) then
                error(errIdentAlreadyDefined);
            new(curEnum = 7);
            curEnum@ := [curIdent, curFrameRegTemplate,
                            symHashTabBase[bucket], curType,
                            ENUMID, NIL, ptr(span)];
            symHashTabBase[bucket] := curEnum;
            span := span + 1;
            if (curField = NIL) then _(
                curType@.enums := curEnum;
            _) else _(
                curField@.list := curEnum;
            _);
            curField := curEnum;
            inSymbol;
            if (SY = COMMA) then _(
                int93z := 0;
                inSymbol;
            _) else _(
                if (SY <> RPAREN) then
                    requiredSymErr(RPAREN);
            _);
        _); (* 12324 *)
        checkSymAndRead(RPAREN);
        if (curField = NIL) then _(
            curType := booleanType;
            error(errNoIdent);
        _) else _(
            curType@ := [1, nrOfBits(span - 1), kindScalar, ,
                          span, 0];
        _);
    _) else (* 12344 *)
    if (SY = ARROW) then _(
        inSymbol;
        if (SY <> IDENT) then _(
            error(errNoIdent);
            curType := pointerType;
        _) else _(
            if (hashTravPtr = NIL) then _(
                if (inTypeDef) then _(
                    if (knownInType(curEnum)) then _(
                        curType := curEnum@.typ;
                    _) else _(
                        definePtrType(integerType);
                    _);
                _) else _(
12366:              error(errNotAType);
                    curType := pointerType;
                _);
            _) else _(
                if (hashTravPtr@.cl <> TYPEID) then _(
                    goto 12366
                _);
                new(curType = 4);
                with curType@ do _(
                    size := 1;
                    bits := 15;
                    k := kindPtr;
                    base := hashTravPtr@.typ;
                _)
            _); (* 12405 *)
            inSymbol;
        _)
    _) else (* 12410 *)
    if (SY = IDENT) then _(
        if (hashTravPtr <> NIL) then _(
            if (hashTravPtr@.cl = TYPEID) then _(
                curType := hashTravPtr@.typ;
            _) else _(
                goto 12760;
            _)
        _) else _(
            if (inTypeDef) then _(
                if (knownInType(curEnum)) then _(
                    curType := curEnum@.typ;
                    curType@.base := booleanType;
                _) else _(
                    definePtrType(booleanType);
                _);
            _) else _(
                error(errNotAType);
                curType := integerType;
            _);
        _);
        inSymbol;
    _) else _( (* 12440 *)
        if (SY = PACKEDSY) then _(
            isPacked := true;
            inSymbol;
            goto 12247;
        _);
        if (SY = RECORDSY) then _( (* 12446 *)
            new(curType = 7);
            typ121z := curType;
            with curType@ do _(
                size := 0;
                bits := 48;
                k := kindRecord;
                ptr1 := NIL;
                first := NIL;
                flag := false;
                pckrec := isPacked;
            _);
            cases.size := 0;
            cases.count := 0;
            parseRecordDecl(curType, true);
            checkSymAndRead(ENDSY);
        _) else (* 12467 *)
        if (SY = ARRAYSY) then _(
            inSymbol;
            if (SY = LBRACK) then
                inSymbol;
            tempType := NIL;
12476:      parseTypeRef(nestedType, skipTarget + [OFSY]);
            curVarKind := nestedType@.k;
            if (curVarKind <> kindRange) then _(
                if (curVarKind = kindScalar) and
                   (nestedType <> integerType) then _(
                    span := nestedType@.numen;
                _) else _(
                    error(8); (* errNotAnIndexType *)
                    nestedType := integerType;
                    span := 10;
                _);
                defineRange(nestedType, 0, span - 1);
            _); (* 12524 *)
            new(l3typ26z, kindArray);
            with l3typ26z@ do _(
                size := ord(tempType);
                bits := 48;
                k := kindArray;
                range := nestedType;
            _);
            if (tempType = NIL) then
                curType := l3typ26z
            else
                tempType@.base := l3typ26z;
            tempType := l3typ26z;
            if (SY = COMMA) then _(
                inSymbol;
                goto 12476;
            _);
            if (SY = RBRACK) then
                inSymbol;
            checkSymAndRead(OFSY);
            parseTypeRef(nestedType, skipTarget);
            l3typ26z@.base := nestedType;
            if isFileType(nestedType) then
                error(errTypeMustNotBeFile);
            repeat with l3typ26z@, ptr2@ do _(
                span := high.i - low + 1;
                tempType := ptr(size);
                l3int22z := base@.bits;
                if (24 < l3int22z) then
                    isPacked := false;
                bits := 48;
                if (isPacked) then _(
                    l3int22z := 48 DIV l3int22z;
                    if (l3int22z = 9) then _(
                        l3int22z := 8;
                    _) else if (l3int22z = 5) then _(
                        l3int22z := 4
                    _);
                    perword := l3int22z;
                    pcksize := 48 DIV l3int22z;
                    l3int22z := span * pcksize;
                    if l3int22z mod 48 = 0 then
                        numBits := 0
                    else
                        numBits := 1;
                    size := l3int22z div 48 + numBits;
                    if (size = 1) then
                        bits := l3int22z;
                _) else _( (* 12633 *)
                    size := span * base@.size;
                    curVal.i := base@.size;
                    curVal.m := ((curVal.m * [7:47]) + [0]);
                    if (range@.base <> integerType) then
                        curVal.m := (curVal.m + [1, 3]);
                    l3typ26z@.perword := KMUL+ I8 + getFCSToffset;
                _); (* 12652 *)
                l3typ26z@.pck := isPacked;
                isPacked := false;
                cond := (curType = l3typ26z);
                l3typ26z := tempType;
            _) until cond;
        _) else (* 12663 *)
        if (SY = FILESY) then _(
            inSymbol;
            checkSymAndRead(OFSY);
            parseTypeRef(nestedType, skipTarget);
            if (isFileType(nestedType)) then
                error(errTypeMustNotBeFile);
            if (isPacked) then _(
                l3int22z := nestedType@.bits;
                if ((24) < l3int22z) then
                    isPacked := false;
            _);
            new(curType, kindFile);
            if (not isPacked) then
                l3int22z := 0;
            with curType@ do _(
                size := 30;
                bits := 48;
                k := kindFile;
                base := nestedType;
                elsize := l3int22z;
            _)
        _) else (* 12721 *)
        if (SY = SETSY) then _(
            inSymbol;
            checkSymAndRead(OFSY);
            parseTypeRef(nestedType, skipTarget);
            with nestedType@ do _(
                if (k = kindRange) and
                   (left >= 0) and
                   (47 >= right) then
                    numBits := right + 1
                else if (k = kindScalar) and
                        (48 >= numen) then
                    numBits := numen
                else _(
                    numBits := 48;
                    error(63); (* errBadBaseTypeForSet *)
                _)
            _);
            new(curType, kindSet);
            with curType@ do _(
                size := 1;
                bits := numBits;
                k := kindSet;
                base := nestedType;
            _)
        _) else _(
12760:      ;
            parseLiteral(tempType, leftBound, true);
            if (tempType <> NIL) then _(
                inSymbol;
                if (SY <> COLON) then _(
                    requiredSymErr(COLON);
                _) else _(
                    inSymbol;
                _);
                parseLiteral(curType, rightBound, true);
                if (curType = tempType) and
                   (curType@.k = kindScalar) then _(
                    defineRange(curType, leftBound.i, rightBound.i);
                    inSymbol;
                    goto 13020;
                _)
            _);
            error(64); (* errIncorrectRangeDefinition *)
            curType := booleanType;
        _);
    _);
13020:
    if (errors) then
        skip(skipToSet + [RPAREN, RBRACK, SEMICOLON, OFSY]);
    newtype := curType;
_); (* parseTypeRef *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure dumpEnumNames(l3arg1z: tptr);
var
    l3var1z: irptr;
_(
    if (l3arg1z@.start = 0) then _(
        l3arg1z@.start := FcstCnt;
        l3var1z := l3arg1z@.enums;
        while (l3var1z <> NIL) do _(
            curVal := l3var1z@.id;
            l3var1z := l3var1z@.list;
            toFCST;
        _)
    _)
_); (* dumpEnumNames *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure formPMD;
var
    l3typ1z: tptr;
    l3var2z: word;
    l3var3z: bitset;
    l3var4z: boolean;
    l3var5z: kind;
_(
    for l3var4z := false to true do _(
        if l3var4z then _(
            optSflags.m := (optSflags.m + [S3]);
            curVal.i := 74001B;
            P0715(2, 34); (*"P/DS"*)
            curVal := procPtr@.id;
            toFCST;
            curVal.i := lineCnt;
            toFCST;
        _); (* 13063 *)
        for temp := 0 to 127 do _(
            curIdRec := symHashTabBase[temp];
            (*13066*)
            while (curIdRec <> NIL) and
                  (procPtr < curIdRec) do with curIdRec@ do _(
                l3var2z.i := typ@.size;
                if (cl IN [VARID, FORMALID]) and
                  (value < 74000B) then _(
                    curVal := id;
                    if (l3var4z) then
                        toFCST;
                    l3typ1z := typ;
                    l3var5z := l3typ1z@.k;
                    l3var3z := [];
                    if (l3var5z = kindPtr) then _(
                        l3typ1z := l3typ1z@.base;
                        l3var5z := l3typ1z@.k;
                        l3var3z := [0];
                    _) else if cl = FORMALID then l3var3z := [0];
                    if (l3typ1z = realType) then
                        curVal.i := 0
                    else if typeCheck(l3typ1z, integerType) then
                        curVal.i := 100000B
                    else if typeCheck(l3typ1z, charType) then
                        curVal.i := 200000B
                    else if (l3var5z = kindArray) then
                        curVal.i := 400000B
                    else if (l3var5z = kindScalar) then _(
                        dumpEnumNames(l3typ1z);
                        curVal.i := 1000000B * l3typ1z@.start + 300000B;
                    _) else if (l3var5z = kindFile) then _(
                        curVal.i := 600000B; l3var3z := [0];
                    _) else _(
                        curVal.i := 500000B;
                    _);
                    curVal.i := curVal.i + curIdRec@.value;
                    l3var2z := l3var2z;
                    besm(ASN64-33);
                    l3var2z := ;
                    curVal.m := curVal.m * [15:47] + l3var2z.m + l3var3z;
                    if (l3var4z) then
                        toFCST;
                _); (* 13164 *)
                curIdRec := curIdRec@.next;
            _); (* 13166 *)
        _); (*13167+*)
        curVal.m := [];
        if l3var4z then
            toFCST;
    _)
_); (* formPMD *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure parseDecls(l3arg1z: integer);
var
    l3int1z: integer;
    l3var2z: word;
    l3var3z: boolean;
_(
    case l3arg1z of
    0: _(
        int93z := 0;
        inSymbol;
        if (SY <> IDENT) then
            errAndSkip(3, skipToSet + [IDENT]);
    _);
    1: _(
        prevErrPos := 0;
        write('IDENT ');
        printTextWord(l2var12z);
        write(' IN LINE ', curIdRec@.offset:0);
    _);
    2: _(
        with procPtr@ do
            ; (* useless *)
        padToLeft;
        l3var3z := 22 IN procPtr@.flags;
        l3arg1z := procPtr@.pos;
        l3var2z.i := moduleOffset - 40000B;
        if (l3arg1z <> (0)) then
            symTab[l3arg1z] := [24, 29] + l3var2z.m * halfWord;
        procPtr@.pos := moduleOffset;
        l3arg1z := F3307(procPtr);
        if l3var3z then _(
            if (41 >= entryPtCnt) then _(
                curVal := procPtr@.id;
                entryPtTable[entryPtCnt] := makeNameWithStars(true);
                entryPtTable[entryPtCnt+1] := [1] + l3var2z.m - [0, 3];
                entryPtCnt := entryPtCnt + 2;
            _) else
                error(87); (* errTooManyEntryProcs *)
        _);
        if (procPtr@.typ = NIL) then _(
            l3var2z.i := 3;
        _) else _(
            l3var2z.i := 4;
        _);
        if l3var3z then
            form2Insn((KVTM+I14) + l3arg1z + (l3var2z.i - 3) * 1000B,
                      getHelperProc(94 (*"P/NN"*)) - 10000000B);
        if 1 < l3arg1z then _(
            l3var2z.i := getValueOrAllocSymtab(-(l3var2z.i+l3arg1z));
        _);
        if (S5 IN optSflags.m) and
           (curProcNesting = 1) then
            l3int1z := 59  (* P/LV *)
        else
            l3int1z := curProcNesting;
        l3int1z := getHelperProc(l3int1z) - (-4000000B);
        if l3arg1z = 1 then _(
            form1Insn((KATX+SP) + l3var2z.i);
        _) else if (l3arg1z <> 0) then _(
            form2Insn(KATX+SP, (KUTM+SP) + l3var2z.i);
        _);
        formAndAlign(l3int1z);
        savedObjIdx := objBufIdx;
        if (curProcNesting <> 1) then
            form1Insn(0);
        if l3var3z then
            form1Insn(KVTM+I8+74001B);
        if (fInitOff <> 0) then _(
            form1Insn(insnTemp[XTA]);
            formAndAlign(KVJM+I13 + fInitOff);
            curVal.i := fInitOff;
            P0715(2, 49 (* "P/RDC" *));
        _);
        if (curProcNesting = 1) then _(
            if (heapCallsCnt <> 0) and
               (heapSize = 0) then
                error(65 (*errCannotHaveK0AndNew*));
            l3var3z := (heapSize = 0) or
                (heapCallsCnt = 0) and (heapSize = 100);
            if (heapSize = 100) then
                heapSize := 4;
            if (not l3var3z) then _(
                form2Insn(KVTM+I14+getValueOrAllocSymtab(heapSize*2000B),
                          getHelperProc(26 (*"P/GD"*)));
                padToLeft;
            _)
        _);
        if (doPMD) then
            formPMD;
    _)
    end; (* case *)
_); (* parseDecls *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure statement;
label
    8888;
var
    boundary: eptr;
    l3var2z: @numLabel;
    l3var3z: @strLabel;
    l3var4z: word;
    l3bool5z: boolean;
    l3var6z: idclass;
    l3var7z, l3var8z: word;
    startLine: integer;
    l3var10z, l3var11z: word;
    l3idr12z: irptr;
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function isCharArray(arg: tptr): boolean;
_(
    with arg@ do
        isCharArray := (k = kindArray) and (base = charType);
_); (* isCharArray *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure expression;
    forward;
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure parseLval;
label
    13462, 13530;
var
    l4exp1z, l4exp2z: eptr;
    l4typ3z: tptr;
    l4var4z: kind;
_(
    if (hashTravPtr@.cl = FIELDID) then _(
        curExpr := expr62z;
        goto 13530;
    _) else _(
        new(curExpr);
        with curExpr@ do _(
            typ := hashTravPtr@.typ;
            op := GETVAR;
            id1 := hashTravPtr;
        _);
13462:  inSymbol;
        l4typ3z := curExpr@.typ;
        l4var4z := l4typ3z@.k;
        if (SY = ARROW) then _(
            new(l4exp1z);
            with l4exp1z@ do _(
                expr1 := curExpr;
                if (l4var4z = kindPtr) then _(
                    typ := l4typ3z@.base;
                    op := DEREF;
                _) else if (l4var4z = kindFile) then _(
                    typ := l4typ3z@.base;
                    op := FILEPTR;
                _) else _(
                    stmtName := '  ^   ';
                    error(errWrongVarTypeBefore);
                    l4exp1z@.typ := l4typ3z;
                _)
            _);
            curExpr := l4exp1z;
        _) else if (SY = PERIOD) then _(
            if (l4var4z = kindRecord) then _(
                int93z := 3;
                typ121z := l4typ3z;
                inSymbol;
                if (hashTravPtr = NIL) then _(
                    error(20); (* errDigitGreaterThan7 ??? *)
                _) else 13530: _(
                    new(l4exp1z);
                    with l4exp1z@ do _(
                        typ := hashTravPtr@.typ;
                        op := GETFIELD;
                        expr1 := curExpr;
                        id2 := hashTravPtr;
                    _);
                    curExpr := l4exp1z;
                _)
            _) else _(
                stmtName := '  .   ';
                error(errWrongVarTypeBefore);
            _);
        _) else if (SY = LBRACK) then _(
            stmtName := '  [   ';
            repeat
                l4exp1z := curExpr;
                expression;
                l4typ3z := l4exp1z@.typ;
                if (l4typ3z@.k <> kindArray) then _(
                    error(errWrongVarTypeBefore);
                _) else _(
                    if (not typeCheck(l4typ3z@.range, curExpr@.typ)) then
                        error(66 (*errOtherIndexTypeNeeded *));
                    new(l4exp2z);
                    with l4exp2z@ do _(
                        typ := l4typ3z@.base;
                        expr1 := l4exp1z;
                        expr2 := curExpr;
                        op := GETELT;
                    _);
                    l4exp1z := l4exp2z;
                _);
                curExpr := l4exp1z;
                stmtName := '  ,   ';
            until (SY <> COMMA);
            if (SY <> RBRACK) then
                error(67 (*errNeedBracketAfterIndices*));
        _) else exit;
    _);
    goto 13462;
_); (* parseLval *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure castToReal(var value: eptr);
var
    cast: eptr;
_(
    new(cast);
    with cast@ do _(
        typ := realType;
        op := TOREAL;
        expr1 := value;
        value := cast;
    _)
_); (* castToReal *)
%
function areTypesCompatible(var l4arg1z: eptr): boolean;
_(
    if (arg1Type = realType) then _(
        if typeCheck(integerType, arg2Type) then _(
            castToReal(l4arg1z);
            areTypesCompatible := true;
            exit
        _);
    _) else if (arg2Type = realType) and
               typeCheck(integerType, arg1Type) then _(
        castToReal(curExpr);
        areTypesCompatible := true;
        exit
    _);
    areTypesCompatible := false;
_); (* areTypesCompatible *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure parseCallArgs(l4arg1z: irptr);
label
    13736;
var
    l4var1z: boolean;
    l4exp2z, l4exp3z, l4exp4z: eptr;
    l4idr5z: irptr;
    l4op6z: operator;
    l4idc7z: idclass;
_(
    with l4arg1z@ do _(
        if typ <> NIL then
            set146z := set146z - flags;
        l4var1z := (list = NIL) and not (24 in flags);
    _);
    new(l4exp3z);
    l4exp4z := l4exp3z;
    bool48z := true;
    with l4exp3z@ do _(
        typ := l4arg1z@.typ;
        op := ALNUM;
        id2 := l4arg1z;
        id1 := NIL;
    _);
    if (SY = LPAREN) then _(
        if (l4var1z) then _(
            l4idr5z := l4arg1z@.argList;
            if (l4idr5z = NIL) then _(
                error(errTooManyArguments);
                goto 8888;
            _)
        _);
        repeat
            if (l4var1z) and (l4arg1z = l4idr5z) then _(
                error(errTooManyArguments);
                goto 8888;
            _);
            bool47z := true;
            expression;
            l4op6z := curExpr@.op;
(a)         if l4var1z then _(
                l4idc7z := l4idr5z@.cl;
                if (l4op6z = PCALL) then _(
                    if (l4idc7z <> ROUTINEID) or
                       (l4idr5z@.typ <> NIL) then _(
13736:                  error(39); (*errIncompatibleArgumentKinds*)
                        exit a
                    _)
                _) else _( (* 13741 *)
                    if (l4op6z = FCALL) then _(
                        if (l4idc7z = ROUTINEID) then _(
                            if (l4idr5z@.typ = NIL) then
                                goto 13736
                        _) else (* 13750 *)
                        if (curExpr@.id2@.argList = NIL) and
                           (l4idc7z = VARID) then _(
                            curExpr@.op := ALNUM;
                            curExpr@.expr1 := NIL;
                        _) else
                            goto 13736;
                    _) else (* 13762 *)
                    if (l4op6z IN lvalOpSet) then _(
                        if (l4idc7z <> VARID) and
                           (l4idc7z <> FORMALID) then
                            goto 13736;
                    _) else _(
                        if (l4idc7z <> VARID) then
                            goto 13736;
                    _)
                _);
                arg1Type := curExpr@.typ;
                if (arg1Type <> NIL) then _(
                    if not typeCheck(arg1Type, l4idr5z@.typ) then
                        error(40); (*errIncompatibleArgumentTypes*)
                _)
            _); (* 14006 *)
            new(l4exp2z);
            with l4exp2z@ do _(
                typ := NIL;
                expr1 := NIL;
                expr2 := curExpr;
            _);
            l4exp4z@.expr1 := l4exp2z;
            l4exp4z := l4exp2z;
            if (l4var1z) then
                l4idr5z := l4idr5z@.list;
        until (SY <> COMMA);
        if (SY <> RPAREN) or
           l4var1z and (l4idr5z <> l4arg1z) then
            error(errNoCommaOrParenOrTooFewArgs)
        else
            inSymbol;
    _) else _( (* 14035 *)
        if (l4var1z) and (l4arg1z@.argList <> NIL) then
            error(42); (*errNoArgList*)
    _);
    curExpr := l4exp3z;
    (* 14042 *)
_); (* parseCallArgs *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure factor;
label
    14567;
var
    l4var1z: word;
    l4var2z: boolean;
    l4var3z, l4var4z: word;
    l4exp5z, l4exp6z, l4var7z, l4var8z: eptr;
    routine: irptr;
    l4op10z: operator;
    l4typ11z: tptr;
    l4var12z: boolean;
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure stdCall;
var
    l5var1z: operator;
    l5var2z: tptr;
    argKind: kind;
    asBitset: bitset;
    stProcNo, checkMode: integer;
_(
    curVal.i := routine@.low;
    stProcNo := curVal.i;
    if (SY <> LPAREN) then _(
        requiredSymErr(LPAREN);
        goto 8888;
    _);
    expression;
    if (stProcNo >= fnEOF) and
       (fnEOLN >= stProcNo) and
       not (curExpr@.op IN [GETELT..FILEPTR]) then _(
        error(27); (* errExpressionWhereVariableExpected *)
        exit;
    _);
    arg1Type := curExpr@.typ;
    if (arg1Type@.k = kindRange) then
        arg1Type := arg1Type@.base;
    argKind := arg1Type@.k;
    if (arg1Type = realType) then
        checkMode := 0
    else if (arg1Type = integerType) then
        checkMode := 1
    else if (arg1Type = charType) then
        checkMode := 2
    else if (argKind = kindScalar) then
        checkMode := 3
    else if (argKind = kindPtr) then
        checkMode := 4
    else if (argKind = kindFile) then
        checkMode := 5
    else if (argKind = kindSet) then
        checkMode := 6
    else _(
        checkMode := 7;
    _);
    asBitset := [stProcNo];
    if not ((checkMode = 0) and
       (asBitset <= [fnSQRT:fnTRUNC, fnREF, fnSQRR, fnROUND]) or
           ((checkMode = 1) and
       (asBitset <= [fnSQRT:fnABSR, fnODD, fnCHR,
                     fnSHIFT, fnREF, fnSQRR, fnPTR])) or
           ((checkMode IN [2, 3, 4]) and
       (asBitset <= [fnORD, fnSUCC, fnPRED, fnREF, fnSHIFT])) or
           ((checkMode = 5) and (asBitset <= [fnEOF..fnEOLN])) or
           ((checkMode = 6) and (asBitset <= [fnREF, fnCARD, fnMINEL])) or
           ((checkMode = 7) and (stProcNo = fnREF))) then
        error(errNeedOtherTypesOfOperands);
    if not (asBitset <= [fnABSR, fnSUCC, fnPRED, fnSQRR, fnSHIFT]) then _(
        arg1Type := routine@.typ;
    _) else if (checkMode = 1) and (asBitset <= [fnABSR, fnSQRR]) then _(
        if stProcNo = fnABSR then
            stProcNo := fnABSI
        else
            stProcNo := fnSQRI;
    _);
    new(l4exp6z);
    l4exp6z@.op := STANDPROC;
    l4exp6z@.expr1 := curExpr;
    l4exp6z@.num2 := stProcNo;
    if stProcNo = fnSHIFT then _(
        if SY <> COMMA then _(
            requiredSymErr(COMMA);
            goto 8888;
        _);
        expression;
        l5var2z := curExpr@.typ;
        l5var1z := badop27;
        if (l5var2z <> realType) and
            not typeCheck(l5var2z, integerType) then
            error(errNeedOtherTypesOfOperands);
        if (l5var2z = realType) then
            l5var1z := badop30
        else if (checkMode = 0) then
            l5var1z := badop31;
        l4exp6z@.expr2 := curExpr;
        l4exp6z@.op := l5var1z;
    _);
    curExpr := l4exp6z;
    curExpr@.typ := arg1Type;
    checkSymAndRead(RPAREN);
    (* 14247 *)
_); (* stdCall *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
_( (* factor *)
    l4var2z := bool47z;
    bool47z := false;
    if (SY < MULOP) then _(
        case SY of
        IDENT: _(
            if (hashTravPtr = NIL) then _(
                error(errNotDefined);
                curExpr := uVarPtr;
            _) else
                case hashTravPtr@.cl of
                TYPEID: _(
%                    error(23); (* errTypeIdInsteadOfVar *)
%                    curExpr := uVarPtr;
                    l4typ11z := hashTravPtr@.typ;
                    inSymbol;
                    if SY <> LPAREN then error(95);
                    expression;
                    if curExpr@.typ@.size <> 1 then
                    error(errNeedOtherTypesOfOperands);                    
                    checkSymAndRead(RPAREN);
                    curExpr@.typ := l4typ11z;
                _);
                ENUMID: _(
                    new(curExpr);
                    with curExpr@ do _(
                        typ := hashTravPtr@.typ;
                        op := GETENUM;
                        num1 := hashTravPtr@.value;
                        num2 := 0;
                    _);
                    inSymbol;
                _);
                ROUTINEID: _(
                    routine := hashTravPtr;
                    inSymbol;
                    if (routine@.offset = 0) then _(
                        if (routine@.typ <> NIL) and
                           (SY = LPAREN) then _(
                            stdCall;
                            exit;
                        _);
                        error(44) (* errIncorrectUsageOfStandProcOrFunc *)
                    _) else if (routine@.typ = NIL) then _(
                        if (l4var2z) then _(
                            l4op10z := PCALL;
                        _) else _(
                            error(68); (* errUsingProcedureInExpression *)
                        _)
                   _) else (* 14330 *) _(
                        if (SY = LPAREN) then _(
                            parseCallArgs(routine);
                            exit
                        _);
                        if (l4var2z) then _(
                            l4op10z := FCALL;
                        _) else _(
                            parseCallArgs(routine);
                            exit
                        _);
                        (q) exit q
                    _); (* 14342 *)
                    new(curExpr);
                    if not (SY IN [RPAREN, COMMA]) then _(
                        error(errNoCommaOrParenOrTooFewArgs);
                        goto 8888;
                    _);
                    with curExpr@ do _(
                        typ := routine@.typ;
                        op := l4op10z;
                        expr1 := NIL;
                        id2 := routine;
                    _)
                _);
                VARID, FORMALID, FIELDID:
                    parseLval;
                end (* case *)
        _);
        LPAREN: _(
            expression;
            checkSymAndRead(RPAREN);
        _);
        INTCONST, REALCONST, CHARCONST, LTSY, GTSY: _(
            new(curExpr);
            parseLiteral(curExpr@.typ, curExpr@.d1, false);
            curExpr@.num2 := ord(suffix);
            curExpr@.op := GETENUM;
            inSymbol;
        _);
        NOTSY: _(
            inSymbol;
            factor;
            if (curExpr@.typ <> booleanType) then
                error(1); (* errNoCommaNorSemicolon *)
            l4exp6z := curExpr;
            new(curExpr);
            with curExpr@ do _(
                typ := booleanType;
                op := NOTOP;
                expr1 := l4exp6z;
            _)
        _);
        LBRACK: _(
            new(curExpr);
            inSymbol;
            l4var8z := curExpr;
            l4var1z.m := [];
            if (SY <> RBRACK) then _(
                l4var12z := true;
                fetch := false;
                repeat
                    l4exp6z := curExpr;
                    expression;
                    if (l4var12z) then _(
                        l4typ11z := curExpr@.typ;
                        if not (l4typ11z@.k IN [kindScalar, kindRange]) then
                            error(23); (* errTypeIdInsteadOfVar *)
                    _) else _(
                        if not typeCheck(l4typ11z, curExpr@.typ) then
                            error(24); (*errIncompatibleExprsInSetCtor*)
                    _);
                    l4var12z := false;
                    l4exp5z := curExpr;
                    if (SY = COLON) then _(
                        expression;
                        if not typeCheck(l4typ11z, curExpr@.typ) then
                            error(24); (*errIncompatibleExprsInSetCtor*)
                        if (l4exp5z@.op = GETENUM) and
                           (curExpr@.op = GETENUM) then _(
                            l4var4z.i := l4exp5z@.num1;
                            l4var3z.i := curExpr@.num1;
                            l4var4z.m := l4var4z.m - intZero;
                            l4var3z.m := l4var3z.m - intZero;
                            l4var1z.m := l4var1z.m + [l4var4z.i..l4var3z.i];
                            curExpr := l4exp6z;
                            goto 14567;
                        _);
                        new(l4var7z);
                        with l4var7z@ do _(
                            typ := setType;
                            op := MKRANGE;
                            expr1 := l4exp5z;
                            expr2 := curExpr;
                        _);
                        l4exp5z := l4var7z;
                   _) else _((* 14535 *)
                        if (l4exp5z@.op = GETENUM) then _(
                            l4var4z.i := l4exp5z@.num1;
                            l4var4z.m := l4var4z.m - intZero;
                            l4var1z.m := l4var1z.m + [l4var4z.i];
                            curExpr := l4exp6z;
                            goto 14567;
                        _);
                        new(l4var7z);
                        with l4var7z@ do _(
                            typ := setType;
                            op := STANDPROC;
                            expr1 := l4exp5z;
                            num2 := 109;
                            l4exp5z := l4var7z;
                        _)
                    _); (* 14560 *)
                    new(curExpr);
                    with curExpr@ do _(
                        typ := setType;
                        op := SETOR;
                        expr1 := l4exp6z;
                        expr2 := l4exp5z;
                    _);
14567:              ;
                until SY <> COMMA;
            _); (* 14571 *)
            checkSymAndRead(RBRACK);
            with l4var8z@ do _(
                op := GETENUM;
                typ := setType;
                d1 := l4var1z;
            _)
        _);
        end; (* case *)
    _) else _(
        error(errBadSymbol);
        goto 8888;
    _)
    (* 14623 *)
_); (* factor *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure term;
label
    14650;
var
    l4var1z: operator;
    l4var2z, l4var3z: eptr;
    l4var4z: boolean;
_(
    factor;
    while (SY = MULOP) do _(
        l4var1z := charClass;
        inSymbol;
        l4var2z := curExpr;
        factor;
        arg1Type := curExpr@.typ;
        arg2Type := l4var2z@.typ;
        l4var4z := typeCheck(arg1Type, arg2Type);
        if (not l4var4z) and
           (RDIVOP < l4var1z) then
14650:      error(errNeedOtherTypesOfOperands)
        else _(
            case l4var1z of
            MUL, RDIVOP: _(
                if (l4var4z) then _(
                    if (arg1Type = realType) then _(
                        (* empty *)
                    _) else _(
                        if (typ120z = integerType) then _(
                            if (l4var1z = MUL) then _(
                                arg1Type := integerType;
                            _) else _(
                                arg1Type := realType;
                            _);
                            l4var1z := imulOpMap[l4var1z];
                        _) else _(
                            if (arg1Type@.k = kindSet) then _(
                                l4var1z := setOpMap[l4var1z];
                            _) else
                                goto 14650;
                        _)
                    _)
                _) else _(
                    if areTypesCompatible(l4var2z) then _(
                        arg1Type := realType;
                    _) else
                        goto 14650;
                _)
            _);
            AMPERS: _(
                if (arg1Type <> booleanType) then
                    goto 14650;
            _);
            IDIVOP: _(
                if (typ120z <> integerType) then
                    goto 14650;
                arg1Type := integerType;
            _);
            IMODOP: _(
                if (typ120z = integerType) then _(
                    arg1Type := integerType;
                _) else _(
                    if (arg1Type@.k = kindSet) then
                        l4var1z := SETXOR
                    else
                        goto 14650;
                _)
            _);
            end;
            new(l4var3z);
            with l4var3z@ do _(
                op := l4var1z;
                expr1 := l4var2z;
                expr2 := curExpr;
                curExpr := l4var3z;
                typ := arg1Type;
            _)
        _)
    _)
    (* 14746 *)
_); (* term *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure simpleExpression;
label
    15031;
var
    l4var1z, l4var2z: eptr;
    l4var3z: operator;
    argKind: kind;
    l4bool5z: boolean;
_(
    l4bool5z := false;
    if (charClass IN [PLUSOP, MINUSOP]) then _(
        if (charClass = MINUSOP) then
            l4bool5z := true;
        inSymbol;
    _);
    term;
(minus)
    if (l4bool5z) then _(
        arg1Type := curExpr@.typ;
        new(l4var2z);
        with l4var2z@ do _(
            typ := arg1Type;
            expr1 := curExpr;
            if (arg1Type = realType) then _(
                op := RNEGOP;
            _) else if typeCheck(arg1Type, integerType) then _(
                l4var2z@.op := INEGOP;
                l4var2z@.typ := integerType;
            _) else _(
                error(69); (* errUnaryMinusNeedRealOrInteger *)
                exit minus
            _);
            curExpr := l4var2z;
        _)
    _); (* 15010 *)
    while (SY = ADDOP) do _(
        l4var3z := charClass;
        inSymbol;
        l4var2z := curExpr;
        term;
        arg1Type := curExpr@.typ;
        arg2Type := l4var2z@.typ;
        l4bool5z := typeCheck(arg1Type, arg2Type);
        argKind := arg2Type@.k;
        if (kindSet < argKind) then _(
15031:      error(errNeedOtherTypesOfOperands);
        _) else _(
            new(l4var1z);
            with l4var1z@ do _(
                if (l4var3z = OROP) then _(
                    if (not l4bool5z) or
                       (arg1Type <> booleanType) then
                        goto 15031;
                    typ := booleanType;
                    op := l4var3z;
                _) else (* 15046 *) _(
                    if (l4bool5z) then _(
                        if (arg1Type = realType) then _(
                            op := l4var3z;
                            typ := realType;
                        _) else if (typ120z = integerType) then _(
                            op := iAddOpMap[l4var3z];
                            typ := integerType;
                        _) else if (argKind = kindSet) then _(
                            op := setOpMap[l4var3z];
                            typ := arg1Type;
                        _) else _(
                            goto 15031
                        _)
                    _) else if areTypesCompatible(l4var2z) then _(
                        l4var1z@.typ := realType;
                        l4var1z@.op := l4var3z;
                    _) else
                        goto 15031
                _); (* 15077 *)
                l4var1z@.expr1 := l4var2z;
                l4var1z@.expr2 := curExpr;
                curExpr := l4var1z;
            _)
        _);
    _)
    (* 15104 *)
_); (* simpleExpression *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure expression;
var
    oper: operator;
    l4var2z, l4var3z: eptr;
_(
    if (fetch) then
        inSymbol
    else
        fetch := true;
    simpleExpression;
    if (SY = RELOP) then _(
        oper := charClass;
        inSymbol;
        l4var3z := curExpr;
        simpleExpression;
        arg1Type := curExpr@.typ;
        arg2Type := l4var3z@.typ;
        if typeCheck(arg1Type, arg2Type) then _(
            if (oper = INOP) or
               (arg1Type@.k = kindFile) or
               (arg1Type@.size <> 1) and
               (oper >= LTOP) and
               not isCharArray(arg1Type) then
                error(errNeedOtherTypesOfOperands);
        _) else (* 15150 *) _(
            if not areTypesCompatible(l4var3z) and
               ((arg1Type@.k <> kindSet) or
               not (arg2Type@.k IN [kindScalar, kindRange]) or
               (oper <> INOP)) then _(
                error(errNeedOtherTypesOfOperands);
            _)
        _); (* 15167 *)
        new(l4var2z);
        if (arg2Type@.k = kindSet) and
           (oper IN [LTOP, GTOP]) then
            error(errNeedOtherTypesOfOperands);
        with l4var2z@ do _(
            typ := booleanType;
            if (oper IN [GTOP, LEOP]) then _(
                expr1 := curExpr;
                expr2 := l4var3z;
                if (oper = GTOP) then
                    op := LTOP
                else
                    op := GEOP;
            _) else _(
                expr1 := l4var3z;
                expr2 := curExpr;
                op := oper;
            _);
            curExpr := l4var2z;
        _)
    _)
    (* 15217 *)
_); (* expression *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure forStatement;
var
    l4typ1z: tptr;
    idx, init, l4var4z: eptr;
    l4int5z, l4int6z, l4int7z, l4int8z: integer;
    hasinit: boolean;
_(
    inSymbol;
    disableNorm;
    curExpr := NIL;
    if (SY = IDENT) then _(
        if (hashTravPtr <> NIL) and (hashTravPtr@.cl = VARID) then _(
            parseLval;
            if (curExpr@.op <> GETVAR) then
                error(errNoSimpleVarForLoop);
        _) else
            error(errNoSimpleVarForLoop);
    _) else _(
        errAndSkip(errNoIdent, skipToSet + [BECOMES, DOSY, TOSY, DOWNTOSY]);
    _); (* 15251 *)
    if (curExpr = NIL) then
        curExpr := uVarPtr;
    idx := curExpr;
    l4typ1z := idx@.typ;
    if not (l4typ1z@.k IN [kindScalar, kindRange]) then
        error(25); (* errExprNotOfADiscreteType *)
    if typeCheck(integerType, l4typ1z) then
        l4int5z := KATX+PLUS1
    else
        l4int5z := KATX+E1;
    if (SY = BECOMES) then _(
        expression;
        hasinit := true;
    _) else _(
        hasinit := false;
    _);
    init := curExpr;
    l4int6z := insnTemp[ADD];
    if not typeCheck(l4typ1z, init@.typ) then
        error(31); (* errIncompatibleTypesOfLoopIndexAndExpr *)
    if (SY = TOSY) then _( _)
    else if (SY = DOWNTOSY) then
        l4int6z := insnTemp[SUB]
    else
        error(70); (* errNeitherToNorDownto *)
    expression;
    if not typeCheck(l4typ1z, curExpr@.typ) then
        error(31); (* errIncompatibleTypesOfLoopIndexAndExpr *)
    formOperator(LOOPLIMIT);
    l4var4z := curExpr;
    if (hasinit) then _(
        curExpr := init;
        formOperator(LOAD);
    _) else _(
        form1Insn(insnTemp[XTA] + l4int5z);
    _);
    l4int7z := 0;
    disableNorm;
    formJump(l4int7z);
    padToLeft;
    l4int8z := moduleOffset;
    checkSymAndRead(DOSY);
    statement;
    disableNorm;
    curExpr := idx;
    formOperator(LOAD);
    form1Insn(l4int6z + l4int5z);
    P0715(0, l4int7z);
    formOperator(STORE);
    curExpr := l4var4z;
    if (l4int6z = insnTemp[SUB]) then
        curVal.i := l4int6z
    else
        curVal.i := insnTemp[RSUB];
    (*15401*)
    formOperator(BINOP);
    form1Insn(insnTemp[UZA] + l4int8z);
_); (* forStatement *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure withStatement;
var
    l4exp1z: eptr;
    l4var2z, l4var3z: bitset;
    l4var4z: integer;
_(
    l4exp1z := expr63z;
    l4var4z := curVarOff;
    l4var2z := set147z;
    l4var3z := [];
    repeat
        inSymbol;
        if (hashTravPtr <> NIL) and
           (hashTravPtr@.cl >= VARID) then _(
            parseLval;
            if (curExpr@.typ@.k = kindRecord) then _(
                formOperator(SETREG);
                l4var3z := (l4var3z + [curVal.i]) * set148z;
            _) else _(
                error(71); (* errWithOperatorNotOfARecord *)
            _);
        _) else _(
            error(72); (* errWithOperatorNotOfAVariable *)
        _)
    until (SY <> COMMA);
    checkSymAndRead(DOSY);
    statement;
    expr63z := l4exp1z;
    curVarOff := l4var4z;
    set147z := l4var2z;
    set145z := set145z + l4var3z;
_); (* withStatement *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure reportStmtType(l4arg1z: integer);
_(
    writeln(' STATEMENT ', stmtname:0, ' IN ', startLine:0, ' LINE');
_); (* reportStmtType *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function structBranch(isGoto: boolean): boolean;
var
    curLab: @strLabel;
_(
    structBranch := true;
    if (SY = IDENT) or not isGoto then _(
        curLab := strLabList;
        ii := 1;
        while (curLab <> NIL) do _(
            with curLab@ do _(
                if (ident.m = []) then _(
                    ii := ii - 1;
                _) else _(
                    if (ident = curIdent) then _(
                        if (ii = 1) then _(
                            if (isGoto) then _(
                                form1Insn(insnTemp[UJ] + offset);
                            _) else _(
                                formJump(curLab@.exitTarget);
                            _);
                        _) else _(
                            form1Insn(getValueOrAllocSymtab(ii) +
                                      (KVTM+I13));
                            if (isGoto) then _(
                                form1Insn(KVTM+I10 + curLab@.offset);
                            _) else _(
                                jumpType := KVTM+I10;
                                formJump(curLab@.exitTarget);
                                jumpType := insnTemp[UJ];
                            _);
                            form1Insn(getHelperProc(60) +
                                      6437777713700000C); (* P/ZAM *)
                        _);
                        exit
                    _)
                _);
                curLab := curLab@.next;
            _)
        _);
        if not isGoto and (SY <> IDENT) then _(
            if (ii <> 1) then _(
                form1Insn(getValueOrAllocSymtab(ii) + (KVTM+I13));
                form1Insn(getHelperProc(60)); (* P/ZAM *)
            _);
            formJump(int53z);
        _) else _(
            error(errNotDefined);
        _)
    _) else
        structBranch := false;
_); (* structBranch *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure caseStatement;
label
    16211;
type
    casechain = record
        next:   @casechain;
        value:  word;
        offset: integer;
    end;
var
    allClauses, curClause, clause, unused: @casechain;
    isIntCase: boolean;
    otherSeen: boolean;
    otherOffset: integer;
    itemsEnded, goodMode: boolean;
    firstType, itemtype, exprtype: tptr;
    itemvalue: word;
    itemSpan: integer;
    expected: word;
    startLine, l4var17z, endOfStmt: integer;
    minValue, unused2, maxValue: word;
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function max(a, b: integer): integer;
_(
    if (b < a) then
        max := a
    else
        max := b;
_); (* max *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
_( (* caseStatement *)
    startLine := lineCnt;
    expression;
    exprtype := curExpr@.typ;
    otherSeen := false;
    if (exprtype = alfaType) or
       (exprtype@.k IN [kindScalar, kindRange]) then
        formOperator(LOAD)
    else
        error(25); (* errExprNotOfADiscreteType *)
    disableNorm;
    l4var17z := 0;
    endOfStmt := 0;
    allClauses := NIL;
    formJump(l4var17z);
    checkSymAndRead(OFSY);
    firstType := NIL;
    goodMode := true;
    (* 15640 *)
    repeat
        if not (SY IN [SEMICOLON, ENDSY]) then _(
            padToLeft;
            arithMode := 1;
            if (SY = OTHERSY) then _(
                if (otherSeen) then
                    error(73); (* errCaseLabelsIdentical *)
                inSymbol;
                otherSeen := true;
                otherOffset := moduleOffset;
            _) else (* 15657 *) repeat
                parseLiteral(itemtype, itemvalue, true);
                if (itemtype <> NIL) then _(
                    if (firstType = NIL) then _(
                        firstType := itemtype;
                    _) else _(
                        if not typeCheck(itemtype, firstType) then
                            error(errConstOfOtherTypeNeeded);
                    _); (* 15700 *)
                    new(clause);
                    clause@.value := itemvalue;
                    clause@.offset := moduleOffset;
                    curClause := allClauses;
(loop)              while (curClause <> NIL) do _(
                        if (itemvalue = curClause@.value) then _(
                            error(73); (* errCaseLabelsIdentical *)
                            exit loop
                        _) else if (itemvalue.i < curClause@.value.i) then _(
                            exit loop
                        _) else _(
                            unused := curClause;
                            curClause := curClause@.next;
                        _)
                    _); (* 15723 *)
                    if (curClause = allClauses) then _(
                        clause@.next := allClauses;
                        allClauses := clause;
                    _) else _(
                        clause@.next := curClause;
                        unused@.next := clause;
                    _);
                    inSymbol;
                _); (* 15735 *)
                itemsEnded := (SY <> COMMA);
                if not itemsEnded then
                    inSymbol;
            until itemsEnded; (* 15745 *)
            checkSymAndRead(COLON);
            statement;
            goodMode := goodMode and (arithMode = 1);
            formJump(endOfStmt);
        _); (* 15762 *)
        itemsEnded := (SY = ENDSY);
        if not itemsEnded then
            inSymbol;
        (* 15771 *)
    until itemsEnded;
    if (SY <> ENDSY) then _(
        requiredSymErr(ENDSY);
        stmtName := 'CASE  ';
        reportStmtType(startLine);
    _) else
        inSymbol;
    if not typeCheck(firstType, exprtype) then _(
        error(88); (* errDifferentTypesOfLabelsAndExpr *);
        exit
    _);
    padToLeft;
    isIntCase := typeCheck(exprtype, integerType);
    if (allClauses <> NIL) then _(
        expected := allClauses@.value;
        minValue := expected;
        curClause := allClauses;
        while (curClause <> NIL) do _(
            if (expected = curClause@.value) and
               (exprtype@.k = kindScalar) then _(
                maxValue := expected;
                if (isIntCase) then _(
                    expected.i := expected.i + 1;
                _) else _(
                    curVal := expected;
                    curVal.c := succ(curVal.c);
                    expected := curVal;
                _);
                curClause := curClause@.next;
            _) else _(
                itemSpan := 34000;
                P0715(0, l4var17z);
                if (firstType@.k = kindRange) then _(
                    itemSpan := max(abs(firstType@.left),
                                    abs(firstType@.right));
                _) else _(
                    if (firstType@.k = kindScalar) then
                        itemSpan := firstType@.numen;
                _);
                itemsEnded := (itemSpan < 32000);
                if (itemsEnded) then _(
                    form1Insn(KATI+14);
                _) else _(
                    form1Insn(KATX+SP+1);
                _);
                minValue.i := (minValue.i - minValue.i); (* WTF? *)
                while (allClauses <> NIL) do _(
                    if (itemsEnded) then _(
                        curVal.i := (minValue.i - allClauses@.value.i);
                        curVal.m := (curVal.m + intZero);
                        form1Insn(getValueOrAllocSymtab(curVal.i) +
                                  (KUTM+I14));
                        form1Insn(KVZM+I14 + allClauses@.offset);
                        minValue := allClauses@.value;
                    _) else _(
                        form1Insn(KXTA+SP+1);
                        curVal := allClauses@.value;
                        form2Insn(KAEX + I8 + getFCSToffset,
                                  insnTemp[UZA] + allClauses@.offset);
                    _);
                    allClauses := allClauses@.next;
                _);
                if (otherSeen) then
                    form1Insn(insnTemp[UJ] + otherOffset);
                goto 16211;
            _); (* if 16141 *)
        _); (* while 16142 *)
        if (not otherSeen) then _(
            otherOffset := moduleOffset;
            formJump(endOfStmt);
        _);
        P0715(0, l4var17z);
        curVal := minValue;
        P0715(-(insnTemp[U1A]+otherOffset), maxValue.i);
        curVal := minValue;
        curVal.m := (curVal.m + intZero);
        form1Insn(KATI+14);
        curVal.i := ((moduleOffset + (1)) - curVal.i);
        if (curVal.i < 40000B) then _(
            curVal.i := (curVal.i - 40000B);
            curVal.i := allocSymtab([24, 29] +
                        (curVal.m * O77777));
        _);
        form1Insn(KUJ+I14 + curVal.i);
        while (allClauses <> NIL) do _(
            padToLeft;
            form1Insn(insnTemp[UJ] + allClauses@.offset);
            allClauses := allClauses@.next;
        _);
        16211:
        P0715(0, endOfStmt);
        if (not goodMode) then
           disableNorm;
        (* 16217 *)
    _)
_); (* caseStatement *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure assignStatement(doLHS: boolean);
label
    16332;
var
    lhsExpr, assnExpr: eptr;
    indCnt: integer;
    srcType, targType: tptr;
_(
    if (doLHS) then
        parseLval
    else _(
        new(curExpr);
        with curExpr@ do _(
            typ := hashTravPtr@.typ;
            op := GETVAR;
            id1 := hashTravPtr;
        _);
        inSymbol;
    _);
    checkSymAndRead(BECOMES);
    fetch := false;
    targType := curExpr@.typ;
    if (targType@.k = kindRecord) and
       (SY = LBRACK) then _(
        formOperator(gen5);
        indCnt := 0;
        inSymbol;
        l3bool5z := false;
(indices)
        _(
            if (SY = COMMA) then _(
                indCnt := indCnt + 1;
                inSymbol;
            _) else if (SY = RBRACK) then _(
                inSymbol;
                exit indices;
            _) else (* 16262 *) _(
                fetch := false;
                expression;
                curVal.i := indCnt;
                formOperator(STOREELT);
            _); (* 16270 *)
            goto indices;
        _);
        curExpr := NIL;
    _) else (* 16273 *)
    if (SY = SEMICOLON) and allowCompat then _(
        formOperator(STORE);
        fetch := true;
        curExpr := NIL;
    _) else (* 16303 *) _(
        lhsExpr := curExpr;
        expression;
        srcType := curExpr@.typ;
        if (typeCheck(targType, srcType)) then _(
            if (srcType@.k = kindFile) then
                error(75) (*errCannotAssignFiles*)
            else _(
                if rangeMismatch and (targType@.k = kindRange) then _(
                    new(assnExpr);
                    with assnExpr@ do _(
                        typ := srcType;
                        op := BOUNDS;
                        expr1 := curExpr;
                        typ2 := targType;
                    _);
                    curExpr := assnExpr;
                _);
16332:          new(assnExpr);
                with assnExpr@ do _(
                    typ := targType;
                    op := ASSIGNOP;
                    expr1 := lhsExpr;
                    expr2 := curExpr;
                _);
                curExpr := assnExpr;
            _)
        _) else if (targType = realType) and
            typeCheck(integerType, srcType) then _(
            castToReal(curExpr);
            goto 16332;
        _) else _(
            error(33); (*errIllegalTypesForAssignment*)
        _)
    _)
    (* 16356 *)
_); (* assignStatement *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure compoundStatement;
_(
(loop) _(
        statement;
        if (SY = SEMICOLON) then _(
            inSymbol;
            goto loop;
        _)
    _)
_); (* compoundStatement *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure ifWhileStatement(delim: symbol);
_(
    disableNorm;
    expression;
    if (curExpr@.typ <> booleanType) then
        error(errBooleanNeeded)
    else _(
        jumpTarget := 0;
        formOperator(gen15);
        l3var10z.i := jumpTarget;
    _);
    checkSymAndRead(delim);
    statement;
_); (* ifWhileStatement *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure parseData;
label
    16545;
type
    DATAREC = record case boolean of
            false: (a: packed array [0..3] of 0..4095);
            true:  (b: bitset)
        end;
var
    dsize, setcount: integer;
    l4var3z, l4var4z, l4var5z: word;
    boundary: eptr;
    l4var7z, l4var8z, l4var9z: word;
    F: file of DATAREC;
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure P16432(l5arg1z: integer);
var
    l5var1z: DATAREC;
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function allocDataRef(l6arg1z: integer): integer;
_(
    if (l6arg1z >= 2048) then _(
        curVal.i := l6arg1z;
        allocDataRef := allocSymtab((curVal.m + [24]) * halfWord);
    _) else _(
        allocDataRef := l6arg1z;
    _)
_); (* allocDataRef *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
_( (* P16432 *)
    l5var1z.a[0] := allocDataRef(l4var4z.i);
    if (FcstCnt = l4var3z.i) then _(
        curVal := l4var8z;
        curVal.i := addCurValToFCST;
    _) else _(
        curVal := l4var3z;
    _);
    l5var1z.a[1] := allocSymtab([12,23] + curVal.m * halfWord);
    l5var1z.a[2] := allocDataRef(l5arg1z);
    if (l4var9z.i = 0) then _(
        curVal := l4var7z;
        besm(ASN64+24);
        curVal := ;
    _) else _(
        curVal.i := allocSymtab(l4var7z.m + l4var9z.m * halfWord);
    _);
    l5var1z.a[3] := curVal.i;
    l4var9z.i := l5arg1z * l4var4z.i + l4var9z.i;
    F@ := l5var1z;
    put(F);
    setcount := setcount + 1;
    l4var4z.i := 0;
    l4var3z.i := FcstCnt;
_); (* P16432 *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
_( (* parseData *)
    dsize := FcstCnt;
    inSymbol;
    setcount := 0;
(loop)
    repeat (* 16530 *)
        inSymbol;
        setup(boundary);
        if SY <> IDENT then _(
            if SY = ENDSY then
                exit loop;
            error(errNoIdent);
            curExpr := uVarPtr;
        _) else (* 16543 *) _(
            if (hashTravPtr = NIL) then _(
16545:          error(errNotDefined);
                curExpr := uVarPtr;
                inSymbol;
            _) else _(
                if (hashTravPtr@.cl = VARID) then _(
                    parseLval;
                _) else goto 16545;
            _)
        _); (* 16557 *)
        putLeft := true;
        objBufIdx := 1;
        formOperator(gen5);
        if (objBufIdx <> 1) then
            error(errVarTooComplex);
        l4var7z.m := (leftInsn * [12,13,14,15,16,17,18,19,20,21,22,23]);
        l4var3z.i := FcstCnt;
        l4var4z.i := 0;
        l4var9z.i := 0;
        repeat (* 16574 *)
            expression;
            formOperator(LITINSN);
            l4var8z := curVal;
            if (SY = COLON) then _(
                inSymbol;
                l4var5z := curToken;
                if (SY <> INTCONST) then _(
                    error(62); (* errIntegerNeeded *)
                    l4var5z.i := 0;
                _) else
                    inSymbol;
            _) else
                l4var5z.i := 1;
            if (l4var5z.i <> 1) then _(
                if (l4var4z.i <> 0) then
                    P16432(1);
                l4var4z.i := 1;
                P16432(l4var5z.i);
            _) else _(
                l4var4z.i := l4var4z.i + 1;
                if (SY = COMMA) then _(
                    curVal := l4var8z;
                    toFCST;
                _) else _(
                    if (l4var4z.i <> 1) then _(
                        curVal := l4var8z;
                        toFCST;
                    _);
                    P16432(1);
                _)
            _); (* 16641 *)
        until SY <> COMMA;
        rollup(boundary);
    until SY <> SEMICOLON; (* 16645 *)
    if (SY <> ENDSY) then
        error(errBadSymbol);
    reset(F);
    while not eof(F) do _(
        write(FCST, F@.b);
        get(F);
    _);
    int92z := FcstCnt - dsize;
    FcstCnt := dsize;
    int93z := setcount;
    (* 16666 *)
_); (* parseData *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure standProc;
label
    17753, 20041;
var
    l4typ1z, l4typ2z, l4typ3z: tptr;
    l4var4z, l4var5z: eptr;
    l4exp6z: eptr;
    l4exp7z, l4exp8z, l4exp9z: eptr;
    l4bool10z,
    l4bool11z, l4bool12z: boolean;
    l4var13z, l4var14z, l4var15z: word;
    procNo: integer;
    helperNo: integer;
    l4var18z: opgen;
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure verifyType(l5arg1z: tptr);
_(
    if (hashTravPtr <> NIL) and
       (hashTravPtr@.cl >= VARID) then _(
        parseLval;
        if (l5arg1z <> NIL) and
           not typeCheck(l5arg1z, curExpr@.typ) then
            error(errNeedOtherTypesOfOperands);
    _) else _(
        error(errNotDefined);
        curExpr := uVarPtr;
    _)
_); (* verifyType *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure startReadOrWrite(l5arg1z: boolean);
_(
    expression;
    l4typ3z := curExpr@.typ;
    l4exp7z := curExpr;
    if not (l5arg1z) then _(
        if not (curExpr@.op IN lvalOpSet) then
            error(27); (* errExpressionWhereVariableExpected *)
    _);
    if (l4exp9z = NIL) then _(
        if (l4typ3z@.k = kindFile) then _(
            l4exp9z := curExpr;
        _) else _(
            new(l4exp9z);
            l4exp9z@.typ := textType;
            l4exp9z@.op := GETVAR;
            if (l5arg1z) then _(
                l4exp9z@.id1 := outputFile;
            _) else _(
                if (inputFile <> NIL) then
                    l4exp9z@.id1 := inputFile
                else (q) _(
                    error(37); (* errInputMissingInProgramHeader *)
                _)
            _)
        _);
        arg2Type := l4exp9z@.typ;
        l4var13z.b := typeCheck(arg2Type@.base, charType);
        l4bool12z := true;
        new(l4exp8z);
        l4exp8z@.typ := arg2Type@.base;
        l4exp8z@.op := FILEPTR;
        l4exp8z@.expr1 := l4exp9z;
        new(l4exp6z);
        l4exp6z@.typ := l4exp8z@.typ;
        l4exp6z@.op := ASSIGNOP;
        if (l5arg1z) then
            l4exp6z@.expr1 := l4exp8z
        else
            l4exp6z@.expr2 := l4exp8z;
    _) (* 17002 *)
_); (* startReadOrWrite *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure parseWidthSpecifier(var l5arg1z: eptr);
_(
    expression;
    if not typeCheck(integerType, curExpr@.typ) then _(
        error(14); (* errExprIsNotInteger *)
        curExpr := uVarPtr;
    _);
    l5arg1z := curExpr;
_); (* parseWidthSpecifier *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure callHelperWithArg;
_(
    if ([12] <= set145z) or l4bool12z then _(
        curExpr := l4exp9z;
        formOperator(gen8);
    _);
    l4bool12z := false;
    formAndAlign(getHelperProc(helperNo));
    disableNorm;
_); (* callHelperWithArg *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure P17037;
_(
    set145z := set145z - [12];
    if (helperNo <> 49) and             (* P/RDC *)
       not typeCheck(l4exp8z@.typ, l4exp7z@.typ) then
        error(34) (* errTypeIsNotAFileElementType *)
    else _(
        if (helperNo = 29) then _(       (* P/PF *)
            l4exp6z@.expr2 := l4exp7z;
        _) else _(
            if (helperNo = 49) then
                helperNo := 30;         (* P/GF *)
            l4exp6z@.expr1 := l4exp7z;
        _);
        curExpr := l4exp6z;
        formOperator(gen7);
        callHelperWithArg;
    _)
_); (* P17037 *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure checkElementForReadWrite;
var
    l5typ1z: tptr;
_(
    set145z := set145z - [12];
    if (l4typ3z@.k = kindRange) then
        l4typ3z := l4typ3z@.base;
    curVarKind := l4typ3z@.k;
    helperNo := 36;                   (* P/WI *)
    if (l4typ3z = integerType) then
        l4var15z.i := 10
    else if (l4typ3z = realType) then _(
        helperNo := 37;               (* P/WR *)
        l4var15z.i := 14;
    _) else if (l4typ3z = charType) then _(
        helperNo := 38;               (* P/WC *)
        l4var15z.i := 1;
    _) else if (curVarKind = kindScalar) then _(
        helperNo := 41;               (* P/WX *)
        dumpEnumNames(l4typ3z);
        l4var15z.i := 8;
    _) else if (isCharArray(l4typ3z)) then _(
        l5typ1z := ref(l4typ3z@.range@);
        l4var15z.i := l5typ1z@.right - l5typ1z@.left + 1;
        if not (l4typ3z@.pck) then
            helperNo := 81            (* P/WA *)
        else if (6 >= l4var15z.i) then
            helperNo := 39            (* P/A6 *)
        else
            helperNo := 40;           (* P/A7 *)
    _) else if (l4typ3z@.size = 1) then _(
        helperNo := 42;               (* P/WO *)
        l4var15z.i := 17;
    _) else _(
        error(34); (* errTypeIsNotAFileElementType *)
    _)
_); (* checkElementForReadWrite *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure writeProc;
_(
    l4exp9z := NIL;
    l4var13z.b := true;
    repeat _(
        startReadOrWrite(true);
        if (l4exp7z <> l4exp9z) then _(
            if not (l4var13z.b) then _(
                helperNo := 29;         (* P/PF *)
                P17037;
            _) else _(
                checkElementForReadWrite;
                l4var5z := NIL;
                l4var4z := NIL;
                if (SY = COLON) then
                    parseWidthSpecifier(l4var4z);
                if (SY = COLON) then _(
                    parseWidthSpecifier(l4var5z);
                    if (helperNo <> 37) then    (* P/WR *)
                        error(35); (* errSecondSpecifierForWriteOnlyForReal *)
                _) else _(
                    if (curToken = litOct) then _(
                        helperNo := 42; (* P/WO *)
                        l4var15z.i := 17;
                        if (l4typ3z@.size <> 1) then
                            error(34); (* errTypeIsNotAFileElementType *)
                        inSymbol;
                    _)
                _);
                l4bool11z := false;
                if (l4var4z = NIL) and
                   (helperNo IN [38,39,40]) then _(  (* WC,A6,A7 *)
                    helperNo := helperNo + 5;       (* CW,6A,7A *)
                    l4bool11z := true;
                _) else _(
                    if (l4var4z = NIL) then _(
                        curVal := l4var15z;
                        formOperator(LOADINT);
                    _) else _(
                        curExpr := l4var4z;
                        formOperator(LOAD);
                    _)
                _);
                if (helperNo = 37) then _(       (* P/WR *)
                    if (l4var5z = NIL) then _(
                        curVal.i := 4;
                        form1Insn(KXTS+I8 + getFCSToffset);
                    _) else _(
                        curExpr := l4var5z;
                        formOperator(PUSHARG);
                    _)
                _);
                curExpr := l4exp7z;
                if (l4bool11z) then _(
                    if (helperNo = 45) then     (* P/7A *)
                        l4var18z := gen11
                    else
                        l4var18z := LOAD;
                _) else _(
                    if (helperNo = 40) or       (* P/A7 *)
                       (helperNo = 81) then     (* P/WA *)
                        l4var18z := gen12
                    else
                        l4var18z := PUSHARG;
                _);
                formOperator(l4var18z);
                if (helperNo IN [39,40,44,45]) or (* A6,A7,6A,7A *)
                   (helperNo = 81) then
                    form1Insn(KVTM+I10 + l4var15z.i)
                else _(
                    if (helperNo = 41) then (* P/WX *)
                        form1Insn(KVTM+I11 + l4typ3z@.start);
                _);
                callHelperWithArg;
            _)
        _)
    _) until (SY <> COMMA);
    if (procNo = 11) then _(
        helperNo := 46;                 (* P/WL *)
        callHelperWithArg;
    _);
    set145z := set145z + [12];
    if (l4var14z.i = moduleOffset) then
        error(36); (*errTooFewArguments *)
_); (* writeProc *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure readProc;
label
    17346, 17362;
_(
    l4exp9z := NIL;
    l4var13z.b := true;
    l4var14z.i := moduleOffset;
    repeat _(
        startReadOrWrite(false);
        if (l4exp7z <> l4exp9z) then _(
            if not (l4var13z.b) then _(
                helperNo := 30;         (* P/GF *)
17346:
                P17037;
           _) else _(
                checkElementForReadWrite;
                if (helperNo = 38) then _(       (* P/WC *)
                    helperNo := 49;             (* P/RDC *)
                    goto 17346;
                _);
                if (helperNo = 39) or           (* A6,A7 *)
                   (helperNo = 40) then _(
                    helperNo := 51;             (* P/RA7 *)
17362:
                    curExpr := l4exp7z;
                    formOperator(gen5);
                    form1Insn(KVTM+I10 + l4var15z.i);
                    callHelperWithArg;
                _) else (q) _(
                    if (helperNo = 81) then _(   (* P/WA *)
                        helperNo := 90;         (* P/RA *)
                        goto 17362;
                    _);
                    helperNo := helperNo + 11;
                    callHelperWithArg;
                    curExpr := l4exp7z;
                    formOperator(STORE);
                _)
            _)
        _)
    _) until (SY <> COMMA);
    set145z := set145z + [12];
    if (procNo = 13) then _(
        helperNo := 53;                 (* P/RL *)
        callHelperWithArg;
    _);
    if (l4var14z.i = moduleOffset) then
        error(36); (* errTooFewArguments *)
_); (* readProc *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure checkArrayArg;
_(
    verifyType(NIL);
    l4exp9z := curExpr;
    l4typ1z := curExpr@.typ;
    if (l4typ1z@.pck) or
       (l4typ1z@.k <> kindArray) then
        error(errNeedOtherTypesOfOperands);
    checkSymAndRead(COMMA);
    fetch := false;
    expression;
    l4exp8z := curExpr;
    if not typeCheck(l4typ1z@.range, l4exp8z@.typ) then
        error(errNeedOtherTypesOfOperands);
_); (* checkArrayArg *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure doPackUnpack;
var
    t: tptr;
_(
    new(l4exp7z);
    l4exp7z@.typ := l4typ1z@.base;
    l4exp7z@.op := GETELT;
    l4exp7z@.expr1 := l4exp9z;
    l4exp7z@.expr2 := l4exp8z;
    t := ref(l4exp6z@.typ@);
    if (t@.k <> kindArray) or
       not t@.pck or
       not typeCheck(t@.base, l4typ1z@.base) or
       not typeCheck(l4typ1z@.range, t@.range) then
        error(errNeedOtherTypesOfOperands);
    new(curExpr);
    curExpr@.val.c := chr(procNo + 50);
    curExpr@.expr1 := l4exp7z;
    curExpr@.expr2 := l4exp6z;
    formOperator(PCKUNPCK);
_); (* doPackUnpack *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
_( (* standProc *)
    curVal.i := l3idr12z@.low;
    procNo := curVal.i;
    l4bool10z := (SY = LPAREN);
    l4var14z.i := moduleOffset;
    if not l4bool10z and
       (procNo IN [0:5,8:10,12,16:28]) then
        error(45); (* errNoOpenParenForStandProc *)
    if (procNo IN [0,1,2,3,4,5,8,9]) then _(
        inSymbol;
        if (hashTravPtr@.cl < VARID) then
            error(46); (* errNoVarForStandProc *)
        parseLval;
        arg1Type := curExpr@.typ;
        curVarKind := arg1Type@.k;
    _);
    if (procNo IN [0..6]) then
        jumpTarget := getHelperProc(29 + procNo); (* P/PF *)
    case procNo of
    0, 1, 2, 3: _( (* put, get, rewrite, reset *)
        if (curVarKind <> kindFile) then
            error(47); (* errNoVarOfFileType *)
        if (procNo = 3) and
           (SY = COMMA) then _(
            formOperator(gen8);
            expression;
            if (not typeCheck(integerType, curExpr@.typ)) then
                error(14); (* errExprIsNotInteger *)
            formOperator(LOAD);
            formAndAlign(getHelperProc(97)); (*"P/RE"*)
        _) else _(
            formOperator(FILEACCESS);
        _)
    _);
    4, 5: _( (* new, dispose *)
        if (curVarKind <> kindPtr) then
            error(13); (* errVarIsNotPointer *)
        heapCallsCnt := heapCallsCnt + 1;
        l4exp9z := curExpr;
        if (procNo = 5) then
            formOperator(gen5);
        curType := arg1Type@.base;
        ii := curType@.size;
        if (charClass = EQOP) then _(
            expression;
            if not typeCheck(integerType, curExpr@.typ) then
                error(14); (* errExprIsNotInteger *)
            formOperator(LOAD);
            form1Insn(KATI+14);
        _) else _(
            if (arg1Type@.base@.k = kindRecord) then _(
                l4typ1z := curType@.base;
(loop)          while (SY = COMMA) and (l4typ1z <> NIL) do _(
                    with l4typ1z@ do
                        ; (* useless *)
                    inSymbol;
                    parseLiteral(l4typ2z, curVal, true);
                    if (l4typ2z = NIL) then
                        exit loop
                    else _(
                        inSymbol;
(loop2)                 while (l4typ1z <> NIL) do _(
                            l4typ2z := l4typ1z;
                            while (l4typ2z <> NIL) do _(
                                if (l4typ2z@.sel = curVal) then _(
                                    ii := l4typ1z@.size;
                                    exit loop2;
                                _);
                                l4typ2z := l4typ2z@.r6;
                            _);
                            l4typ1z := l4typ1z@.next;
                        _);
                    _);
                _)
            _);
            form1Insn(KVTM+I14+getValueOrAllocSymtab(ii));
        _);
        formAndAlign(jumpTarget);
        if procNo = 4 then _(
            curExpr := l4exp9z;
            formOperator(STORE);
        _)
    _);
    6: _( (* halt *)
        formAndAlign(jumpTarget);
        exit
    _);
    7: _( (* stop *)
        form1Insn(KE74);
        exit
    _);
    8, 9: _( (* setup, rollup *)
        if (curVarKind <> kindPtr) then
            error(13); (* errVarIsNotPointer *)
        if (procNo = 8) then _(
            form1Insn(KXTA+HEAPPTR);
            formOperator(STORE);
        _) else _(
            formOperator(LOAD);
            form1Insn(KATX+HEAPPTR);
        _)
    _);
    10: _( (* write *)
        writeProc;
    _);
    11:
17753: _( (* writeln *)
        if SY = LPAREN then _(
            writeProc;
        _) else _(
            formAndAlign(getHelperProc(54)); (*"P/WOLN"*)
            exit
        _)
    _);
    12: _( (* read *)
        readProc;
    _);
    13: _( (* readln *)
        if (SY = LPAREN) then _(
            readProc;
        _) else _(
            formAndAlign(getHelperProc(55)); (*"P/RILN"*)
            exit
        _)
    _);
    14: _( (* exit *)
        l4bool10z := (SY = LPAREN);
        if (l4bool10z) then
            inSymbol;
        if (SY = IDENT) then _(
            if not structBranch(false) then
                error(1); (* errCommaOrSemicolonNeeded *)
            inSymbol;
        _) else _(
            formJump(int53z);
        _);
        if not (l4bool10z) then
            exit
    _);
    15: _( (* debug *)
        if (debugPrint IN optSflags.m) then _(
            procNo := 11;
            goto 17753;
        _);
        while (SY <> RPAREN) do
            inSymbol;
    _);
    16: repeat (* besm *)
        expression;
        formOperator(LITINSN);
        if (SY = RPAREN) or (SY = COMMA) then 
            form1Insn(curVal.i)
        else  _(
            besmInsn := curVal;
            checkSymAndRead(COLON);
            if SY = IDENT then _(
% Expecting a LHS-like construct; forming STORE
% keeps Acc intact, and the last constructed op
% will be ATX.
                verifyType(NIL);
                formOperator(STORE);
            _) else _(
                fetch := false;
                expression;
% Expecting a constant, loading it with XTA would be the last op.
                if (curExpr@.op <> GETENUM) then
                    error(errNeedOtherTypesOfOperands);
                formOperator(LOAD);
            _);
% Patch the last instruction with the opcode of the argument of BESM
            if putLeft then
                objBuffer[objBufIdx-1] :=
                    objBuffer[objBufIdx-1] - [28, 30..35] +
                    besmInsn.m * [28, 30..35]
            else _(
                besmInsn.m := besmInsn.m * [28, 30..35];
                besm(ASN64-24);
                besmInsn :=;
                leftInsn := leftInsn -[4, 6..11] + besmInsn.m;
            _)
        _);
    until SY = RPAREN;
    17: _( (* mapia *)
        l4typ1z := integerType;
        l4typ2z := alfaType;
20041:
        expression;
        if not typeCheck(curExpr@.typ, l4typ1z) then
            error(errNeedOtherTypesOfOperands);
        checkSymAndRead(COMMA);
        formOperator(LOAD);
        if (procNo = 17) then _(
            form3Insn(ASN64-33, KAUX+BITS15, KAEX+ASCII0);
        _) else _(
            form3Insn(KAPX+BITS15, ASN64+33, KAEX+ZERO);
        _);
        verifyType(l4typ2z);
        formOperator(STORE);
    _);
    18: _( (* mapai *)
        l4typ1z := alfaType;
        l4typ2z := integerType;
        goto 20041;
    _);
    19, 20: _( (* pck, unpck *)
        inSymbol;
        verifyType(charType);
        checkSymAndRead(COMMA);
        formOperator(gen8);
        verifyType(alfaType);
        if (procNo = 20) then _(
            formOperator(LOAD);
        _);
        formAndAlign(getHelperProc(procNo - 6));
        if (procNo = 19) then
            formOperator(STORE);
    _);
    21: _( (* pack *)
        inSymbol;
        checkArrayArg;
        checkSymAndRead(COMMA);
        verifyType(NIL);
        l4exp6z := curExpr;
        doPackUnpack;
    _);
    22: _( (* unpack *)
        inSymbol;
        verifyType(NIL);
        l4exp6z := curExpr;
        checkSymAndRead(COMMA);
        checkArrayArg;
        doPackUnpack;
    _);
    23, 24, 25, 26, 27, 28: _( (* MARS procedures *)
        l3bool5z := 24 < procNo;
        repeat _(
            expression;
            if (curExpr@.typ@.size <> 1) then
                error(5); (*errSimpleTypeReq*)
            formOperator(LOAD);
            if (l3bool5z) then _(
                checkSymAndRead(COMMA);
                verifyType(NIL);
                l4exp9z := curExpr;
                if (SY = COLON) then _(
                    expression;
                    formOperator(PUSHARG);
                _) else _(
                    form2Insn(KVTM + I14 + l4exp9z@.typ@.size,
                              KITS + 14);
                _);
                curExpr := l4exp9z;
                formOperator(gen12);
            _) else _(
                form2Insn(insnTemp[XTS], insnTemp[XTS]);
            _);
            form1Insn(KWTC + I14 + 77751B + procNo);
            formAndAlign(getHelperProc(80)); (*"PAIB"*)
        _) until (SY <> COMMA);
    _);
    29: _( (* called via FIND, fake *)
        expression;
        formOperator(LOAD);
        curVal.i := 1264645157120000C(*"*TTIO*"*);
        procNo := allocExtSymbol([24,27:29,43,45,46]);
        form2Insn(2200000B + procNo, 3);
    _)
    end; (* 20257 *)
    if procNo in [0,1,2,3,5,10,11,12,13,21,22] then
        arithMode := 1;
    checkSymAndRead(RPAREN);
    (* 20265 *)
_); (* standProc *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
_( (* statement *)
    setup(boundary);
    bool110z := false;
    startLine := lineCnt;
    if set147z = halfWord then
        parseData
    else _(
        if SY = INTCONST then _(
            set146z := [];
            l3var2z := numLabList;
            disableNorm;
            l3bool5z := true;
            padToLeft;
            while l3var2z <> l2var16z do _( with l3var2z@ do
                if id <> curToken then _(
                    l3var2z := next;
                _) else _(
                    l3bool5z := false;
                    if (defined) then _(
                        curVal.i := line;
                        error(17); (* errLblAlreadyDefinedInLine *);
                    _) else _(
                        l3var2z@.line := lineCnt;
                        l3var2z@.defined := true;
                        padToLeft;
                        if l3var2z@.offset = 0 then _(
                            (* empty *)
                        _) else if (l3var2z@.offset >= 74000B) then _(
                            curVal.i := (moduleOffset - 40000B);
                            symTab[l3var2z@.offset] := [24,29] +
                                                         curVal.m * O77777;
                        _) else _(
                            P0715(0, l3var2z@.offset);
                        _); (* 20342 *)
                        l3var2z@.offset := moduleOffset;
                    _);
                    l3var2z := l2var16z;
                _);
            _); (* while 20346 *)
            if (l3bool5z) then
                error(16); (* errLblNotDefinedInBlock *);
            inSymbol;
            checkSymAndRead(COLON);
        _); (* 20355*)
        if (DebugInteractive IN optSflags.m) and
           (debugLine <> lineCnt) then _(
            P0715(-1, 96 (* "P/DD" *));
            debugLine := lineCnt;
            arithMode := 1;
        _);
        l3var4z.b := (SY IN [BEGINSY,CASESY,REPEATSY,SELECTSY]);
        if (l3var4z.b) then
            lineNesting := lineNesting + 1;
(ident)
        if SY = IDENT then _(
            if hashTravPtr <> NIL then _(
                l3var6z := hashTravPtr@.cl;
                if l3var6z >= VARID then _(
                    assignStatement(true);
                _) else _(
                    if l3var6z = ROUTINEID then _(
                        if hashTravPtr@.typ = NIL then _(
                            l3idr12z := hashTravPtr;
                            inSymbol;
                            if l3idr12z@.offset = 0 then _(
                                standProc;
                                exit ident;
                            _);
                            parseCallArgs(l3idr12z);
                        _) else _(
                            assignStatement(false);
                        _);
                    _) else _(
                        error(32); (* errWrongStartOfOperator *)
                        goto 8888;
                    _)
                _);
                formOperator(gen7);
            _) else _(
                error(errNotDefined);
8888:           skip(skipToSet + statEndSys);
            _);
        _) else (* 20431 *) if (SY = LPAREN) then _(
            set146z := [];
            inSymbol;
            if (SY <> IDENT) then _(
                error(errNoIdent);
                goto 8888;
            _);
            new(l3var3z);
            padToLeft;
            disableNorm;
            with l3var3z@ do _(
                next := strLabList;
                ident := curIdent;
                offset := moduleOffset;
                exitTarget := 0;
            _);
            strLabList := l3var3z;
            inSymbol;
            checkSymAndRead(RPAREN);
            statement;
            P0715(0, l3var3z@.exitTarget);
            strLabList := strLabList@.next;
        _) else (* 20463 *) if (SY = BEGINSY) then
(rep)   _(
            inSymbol;
(skip)      _(
                compoundStatement;
                if (SY <> ENDSY) then _(
                    stmtName := ' BEGIN';
                    requiredSymErr(SEMICOLON);
                    reportStmtType(startLine);
                    skip(bigSkipSet);
                    if (SY IN statBegSys) then
                        goto skip;
                    if (SY <> SEMICOLON) then
                        exit rep;
                    goto rep;
                _);
            _);
            inSymbol;
        _) else (* 20511 *) if (SY = GOTOSY) then _(
            inSymbol;
            if (SY <> INTCONST) then _(
                if structBranch(true) then _(
                    inSymbol;
                    exit;
                _) else
                    goto 8888;
            _);
            disableNorm;
            l3var2z := numLabList;
(loop)      if (l3var2z <> NIL) then with l3var2z@ do _(
                if (id <> curToken) then _(
                    l3var2z := next;
                _) else _(
                    if (curFrameRegTemplate = frame) then _(
                        if (offset >= 40000B) then _(
                            form1Insn(insnTemp[UJ] + offset);
                        _) else _(
                            formJump(offset);
                        _)
                    _) else _(
                        if offset = 0 then _(
                            offset := symTabPos;
                            putToSymTab([]);
                        _);
                        form3Insn(frame + (KMTJ + 13), KVTM+I14 + offset,
                                  getHelperProc(18(*"P/RC"*)) + (-64100000B));
                    _);
                    exit loop;
                _);
                goto loop;
            _) else
                error(18); (* errLblNotDefined *)
            inSymbol;
        _) else (* 20571 *) if (SY = IFSY) then _(
            ifWhileStatement(THENSY);
            if (SY = ELSESY) then _(
                l3var11z.i := 0;
                formJump(l3var11z.i);
                P0715(0, l3var10z.i);
                l3var8z.i := arithMode;
                arithMode := 1;
                inSymbol;
                statement;
                P0715(0, l3var11z.i);
                if (l3var8z.i <> arithMode) then _(
                    arithMode := 2;
                    disableNorm;
                _)
            _) else _(
                P0715(0, l3var10z.i);
            _)
        _) else (* 20625 *) if (SY = WHILESY) then _(
            set146z := [];
            disableNorm;
            padToLeft;
            l3var8z.i := moduleOffset;
            ifWhileStatement(DOSY);
            disableNorm;
            form1Insn(insnTemp[UJ] + l3var8z.i);
            P0715(0, l3var10z.i);
            arithMode := 1;
        _) else (* 20644 *) if (SY = REPEATSY) then _(
            set146z := [];
            disableNorm;
            padToLeft;
            l3var7z.i := moduleOffset;
            repeat
                inSymbol;
                statement;
            until (SY <> SEMICOLON);
            if (SY <> UNTILSY) then _(
                requiredSymErr(UNTILSY);
                stmtName := 'REPEAT';
                reportStmtType(startLine);
                goto 8888;
            _);
            disableNorm;
            expression;
            if (curExpr@.typ <> booleanType) then _(
                error(errBooleanNeeded)
            _) else _(
                jumpTarget := l3var7z.i;
                formOperator(gen15);
            _);
        _) else (* 20676 *)
        if SY = FORSY then _(
            set146z := [];
            forStatement;
        _) else (* 20702 *) if SY = SELECTSY then _(
            disableNorm;
            l3bool5z := true;
            l3var11z.i := 0;
            (* 20707 *)
            repeat
                arithMode := 1;
                expression;
		if curExpr@.typ <> booleanType then _(
		    error(errBooleanNeeded);
		_) else _(
		    jumpTarget := 0;
		    formOperator(gen15);
		    l3var10z.i := jumpTarget;
		_);
		checkSymAndRead(COLON);
		statement;
		formJump(l3var11z.i);
		l3bool5z := l3bool5z and (arithMode = 1);
		P0715(0, l3var10z.i);
	    until (SY <> SEMICOLON);
	    checkSymAndRead(ENDSY);
	    P0715(0, l3var11z.i);
	    if not l3bool5z then _(
	        arithMode := 2;
	        disableNorm;
	    _)
	_) else (* 20751 *) if (SY = CASESY) then _(
		    caseStatement
		_) else if (SY = WITHSY) then _(
		    withStatement;
		_); (* 20757 *)
		if (l3var4z.b) then
		    lineNesting := lineNesting - 1;
		rollup(boundary);
		if (bool110z) then _(
		    bool110z := false;
		    goto 8888;
		_)
	    _)
	    (* 20766 *)
	_); (* statement *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	procedure outputObjFile;
	var
	    idx: integer;
	_(
	    padToLeft;
	    objBufIdx := objBufIdx - 1;
	    for idx to objBufIdx do
		write(CHILD, objBuffer[idx]);
	    lineStartOffset := moduleOffset;
	    prevOpcode := -1;
	_); (* outputObjFile *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	procedure defineRoutine;
	var
	    l3var1z, l3var2z, l3var3z: word;
	    l3int4z: integer;
	    l3idr5z: irptr;
	    l3var6z, l3var7z: word;
	_(
	    objBufIdx := 1;
	    objBuffer[objBufIdx] := [];
	    curInsnTemplate := insnTemp[XTA];
            prevOpcode := -1;
	    bool48z := 22 IN procPtr@.flags;
	    lineStartOffset := moduleOffset;
	    l3var1z := ;
	    int92z := 2;
	    expr63z := NIL;
	    arithMode := 1;
	    set146z := [];
	    set147z := [curProcNesting+1..6];
	    set148z := set147z - [minel(set147z)];
	    l3var7z.m := set147z;
	    int53z := 0;
	    set145z := [1:15] - set147z;
	    if (curProcNesting <> 1) then
		parseDecls(2);
	    l2int21z := curVarOff;
	    if (SY <> BEGINSY) then
		requiredSymErr(BEGINSY);
	    if 23 IN procPtr@.flags then _(
		l3idr5z := procPtr@.argList;
		l3int4z := 3;
		if (procPtr@.typ <> NIL) then
		l3int4z := 4;
		while (l3idr5z <> procPtr) do _(
		    if (l3idr5z@.cl = VARID) then _(
			l3var2z.i := l3idr5z@.typ@.size;
			if (l3var2z.i <> 1) then _(
			    form3Insn(KVTM+I14 + l3int4z,
				      KVTM+I12 + l3var2z.i,
				      KVTM+I11 + l3idr5z@.value);
			    formAndAlign(getHelperProc(73)); (* "P/LNGPAR" *)
			_)
		    _);
		    l3int4z := l3int4z + 1;
		    l3idr5z := l3idr5z@.list;
		_)
	    _); (* 21105 *)
	    if checkBounds or not (NoStackCheck IN optSflags.m) then
		P0715(-1, 95); (* P/SC *)
	    l3var2z.i := lineNesting;
	    repeat
		statement;
		if (SY = SEMICOLON) then _(
		    if (curProcNesting = 1) then
			requiredSymErr(PERIOD);
		    inSymbol;
		    l2bool8z := (SY IN blockBegSys);
            if not l2bool8z and not errors then
            error(84); (* errErrorInDeclarations *)
	_) else _(
            if (SY = PERIOD) and (curProcNesting = 1) then
		l2bool8z := true
	    else (q) _(
		errAndSkip(errBadSymbol, skipToSet);
	        l2bool8z := (SY IN blockBegSys);
            _)
        _);
    until l2bool8z;
    procPtr@.flags := (set145z * [0:15]) + (procPtr@.flags - l3var7z.m);
    lineNesting := l3var2z.i - 1;
    if (int53z <> 0) then
	P0715(0, int53z);
    if not bool48z and not doPMD and (l2int21z = 3) and
       (curProcNesting <> 1) and (set145z * [1:15] <> [1:15]) then _(
	objBuffer[1] := [7:11,21:23,28,31];
	with procPtr@ do
	    flags := flags + [25];
	if (objBufIdx = 2) then _(
	    objBuffer[1] := [0,1,3:5];
	    putLeft := true;
	_) else _(
	    procPtr@.pos := l3var1z.i;
	    if 13 IN set145z then _(
		curVal.i := minel([1:15] - set145z);
		besm(ASN64-24);
		l3var7z := ;
		objBuffer[2] := objBuffer[2] + [0,1,3,6,9] + l3var7z.m;
	    _) else _(
		curVal.i := (13);
	    _);
	    form1Insn(insnTemp[UJ] + indexreg[curVal.i]);
	_)
    _) else (* 21220 *) _(
	if (fInitOff = 0) then
	    temp := 27
	else
	    temp := 28;
	form1Insn(getHelperProc(temp) + (-I13-100000B));
	if (curProcNesting = 1) then _(
	    parseDecls(2);
	    if S3 IN optSflags.m then
		formAndAlign(getHelperProc(78)); (* "P/PMDSET" *)
	    form1Insn(insnTemp[UJ] + l3var1z.i);
	    curVal.i := procPtr@.pos - 40000B;
	    symTab[74002B] := [24,29] + (curVal.m * halfWord);
	_);
	curVal.i := l2int21z;
	if (curProcNesting <> 1) then _(
	    curVal.i := curVal.i - 2;
	    l3var7z := curVal;
	    besm(ASN64-24);
	    l3var7z := ;
	    objBuffer[savedObjIdx] := objBuffer[savedObjIdx] +
                                   l3var7z.m + [0,1,2,3,4,6,8];
	_)
    _); (* 21261 *)
    outputObjFile;
_); (* defineRoutine *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	procedure initScalars;
	var
	    l3var1z, noProgram, outName, inName: word;
	    l3var5z, l3var6z: integer;
	    l3var7z: irptr;
	    l3var8z, l3var9z: integer;
	    temptype: tptr;
	    filePattern: word;
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	procedure regSysType(l4arg1z:integer; l4arg2z: tptr);
	_(
	    new(curIdRec = 5);
	    curIdRec@ := [l4arg1z, 0, , l4arg2z, TYPEID];
	    addToHashTab(curIdRec);
	_); (* regSysType *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	procedure regSysEnum(l4arg1z: integer; l4arg2z: integer);
	_(
	    new(curIdRec = 7);
	    curIdRec@ := [l4arg1z, 48, , temptype, ENUMID, NIL, l4arg2z];
	    addToHashTab(curIdRec);
	_); (* regSysEnum *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	procedure regSysProc(l4arg1z: integer);
	_(
	    new(curIdRec = 6);
	    curIdRec@ := [l4arg1z, 0, , temptype, ROUTINEID, l3var9z];
	    l3var9z := l3var9z + 1;
	    addToHashTab(curIdRec);
	_); (* registerSysProc *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	_( (* initScalars *)
	    new(booleanType, kindScalar);
	    with booleanType@ do _(
		size := 1;
		bits := 1;
		k := kindScalar;
		numen := 2;
		start := 0;
	    _);
	    new(integerType, kindScalar);
	    with integerType@ do _(
		size := 1;
		bits := 48;
		k := kindScalar;
		numen := 100000;
		start := -1;
		enums := NIL;
	    _);
	    new(charType, kindScalar);
	    with charType@ do _(
		size := 1;
		bits := (8);
		k := kindScalar;
		numen := 256;
		start := -1;
		enums := NIL;
	    _);
	    new(realType, kindArray);   (* could use kindReal to save 5 words *)
	    with realType@ do _(
		size := 1;
		bits := 48;
		k := kindReal;
	    _);
	    new(setType, kindSet);
	    with setType@ do _(
		size := 1;
		bits := 48;
		k := kindSet;
		base := integerType;
	    _);
	    new(pointerType, kindPtr);
	    with pointerType@ do _(
		size := 1;
		bits := 48;
		k := kindPtr;
		base := pointerType;
	    _);
	    new(textType, kindFile);
	    with textType@ do _(
		size := 30;
		bits := 48;
		k := kindFile;
		base := charType;
		elsize := 8;
	    _);
	    new(alfaType,kindArray);
	    with alfaType@ do _(
		size := 1;
		bits := 48;
		k := kindArray;
		base := charType;
		range := temptype;
		pck := true;
		perword := 6;
		pcksize := 8;
	    _);
	    smallStringType[6] := alfaType;
	    regSysType(51566445474562C(*" INTEGER"*), integerType);
	    regSysType(42575754454156C(*" BOOLEAN"*), booleanType);
	    regSysType(43504162C(*"    CHAR"*), charType);
	    regSysType(62454154C(*"    REAL"*), realType);
	    regSysType(41544641C(*"    ALFA"*), alfaType);
	    regSysType(64457064C(*"    TEXT"*), textType);
	    temptype := booleanType;
	    regSysEnum(64626545C(*"    TRUE"*), (1C));
	    hashTravPtr := curIdRec;
	    regSysEnum(4641546345C(*"   FALSE"*), (0C));
	    curIdRec@.list := hashTravPtr;
	    booleanType@.enums := curIdRec;
	    maxSmallString := 0;
	    for strLen := 2 to 5 do
		makeStringType(smallStringType[strLen]);
	    maxSmallString := 6;
	    new(curIdRec = 7);
	    with curIdRec@ do _(
		offset := 0;
		typ := integerType;
		cl := VARID;
		list := NIL;
		value := 7;
	    _);
	    new(uVarPtr);
	    with uVarPtr@ do _(
		typ := integerType;
		op := GETVAR;
		id1 := curIdRec;
	    _);
	    new(uProcPtr, 12);
	    with uProcPtr@ do _(
		typ := NIL;
		list := NIL;
		argList := NIL;
		preDefLink := NIL;
		pos := 0;
	    _);
	    temptype := NIL;
	    l3var9z := 0;
	    for l3var5z := 0 to 29 do
		regSysProc(systemProcNames[l3var5z]);
	    l3var9z := 0;
	    temptype := realType;
	    regSysProc(63616264C(*"    SQRT"*));
	    regSysProc(635156C(*"     SIN"*));
	    regSysProc(435763C(*"     COS"*));
	    regSysProc(416243644156C(*"  ARCTAN"*));
	    regSysProc(416243635156C(*"  ARCSIN"*));
	    regSysProc(5456C(*"      LN"*));
	    regSysProc(457060C(*"     EXP"*));
	    regSysProc(414263C(*"     ABS"*));
	    temptype := integerType;
	    regSysProc(6462655643C(*"   TRUNC"*));
	    temptype := booleanType;
	    regSysProc(574444C(*"     ODD"*));
	    temptype := integerType;
	    regSysProc(576244C(*"     ORD"*));
	    temptype := charType;
	    regSysProc(435062C(*"     CHR"*));
	    regSysProc(63654343C(*"    SUCC"*));
	    regSysProc(60624544C(*"    PRED"*));
	    temptype := booleanType;
	    regSysProc(455746C(*"     EOF"*));
	    temptype := pointerType;
	    regSysProc(624546C(*"     REF"*));
	    temptype := booleanType;
	    regSysProc(45575456C(*"    EOLN"*));
	    temptype := integerType;
	    regSysProc(636162C(*"     SQR"*));
	    regSysProc(6257655644C(*"   ROUND"*));
	    regSysProc(43416244C(*"    CARD"*));
	    regSysProc(5551564554C(*"   MINEL"*));
	    temptype := pointerType;
	    regSysProc(606462C(*"     PTR"*));
	    regSysProc(6350514664C(*"   SHIFT"*));
	    filePattern.i := 30;
	    filePattern.m := filePattern.m * halfWord + [24,27,28,29];
	    new(programObj, 12);
	    outName.i := 576564606564C(*"  OUTPUT"*);
	    inName.i := 5156606564C(*"   INPUT"*);
	    noProgram.i := 5657606257476241C(*"NOPROGRA"*);
	    test1(PROGRAMSY, (skipToSet + [IDENT,LPAREN]));
	    symTabPos := 74004B;
	    with programObj@ do _(
		if (SY = IDENT) then _(
		    curVal := curIdent;
		    id := ;
		    pos := 0;
		    symTab[74000B] := makeNameWithStars(true);
		_) else _(
		    id.m := [3];
		    error(errNoIdent);
		    skip(skipToSet + [LPAREN]);
		_);
	    _);
	    if (curIdent <> noProgram) then _(
		entryPtTable[1] := symTab[74000B];
		entryPtTable[3] :=
		    [0,1,6,7,10,12,14:18,21:25,28,30,35,36,38,39,41];(*"PROGRAM "*)
		entryPtTable[2] := [1];
		entryPtTable[4] := [1];
		entryPtCnt := 5;
		write(CHILD, [0,4,6,9:12,23,28,29,33:36,46]);(*10 24 74001 00 30 74002*)
		moduleOffset := 40001B;
	    _) else _(
		entryPtCnt := 1;
		moduleOffset := 40000B;
	    _);
	    programObj@.argList := NIL;
	    programObj@.flags := [];
	    objBufIdx := 1;
	    temptype := integerType;
	    defineRange(temptype, 1, 6);
	    alfaType@.range := temptype;
	    int93z := 0;
	    inSymbol;
	    test1(LPAREN, skipToSet + [IDENT]);
	    outputObjFile;
	    outputFile := NIL;
	    inputFile := NIL;
	    externFileList := NIL;
	    new(l3var7z, 12);
	    lineStartOffset := moduleOffset;
	    with l3var7z@ do _(
		id := outName;
		offset := 0;
		typ := textType;
		cl := VARID;
		list := NIL;
	    _);
	    curVal.i := 1257656460656412C(*"*OUTPUT*"*);
	    l3var7z@.value := allocExtSymbol(filePattern.m);
	    addToHashTab(l3var7z);
	    l3var5z := 1;
	    while SY = IDENT do _(
		l3var8z := 0;
		curVal := curIdent;
		l3var1z.m := makeNameWithStars(false);
		if (curIdent = inName) then _(
		    new(inputFile, 12);
		    with inputFile@ do _(
			id := curIdent;
			offset := 0;
			typ := textType;
			cl := VARID;
			list := NIL;
		    _);
		    curVal := l3var1z;
		    inputFile@.value := allocExtSymbol(filePattern.m);
		    addToHashTab(inputFile);
		    l3var8z := lineCnt;
		_) else if (curIdent = outName) then _(
		    outputFile := l3var7z;
		    l3var8z := lineCnt;
		_); (* 21745 *)
		curExternFile := externFileList;
		while (curExternFile <> NIL) do _(
		    if (curExternFile@.id = curIdent) then _(
			curExternFile := NIL;
			error(errIdentAlreadyDefined);
		    _) else _(
			curExternFile := curExternFile@.next;
		    _);
		_); (* 21760 *)
		new(curExternFile);
		with curExternFile@ do _(
		    id := curIdent;
		    next := externFileList;
		    line := l3var8z;
		    offset := l3var1z.i;
		_);
		if l3var8z <> 0 then _(
		    if (curIdent = outName) then _(
			fileForOutput := curExternFile;
		    _) else _(
			fileForInput := curExternFile;
		    _)
		_);
		externFileList := curExternFile;
		l3var6z := l3var5z;
		l3var5z := l3var5z + 1;
		inSymbol;
		if (charClass = MUL) then _(
		    l3var6z := l3var6z + 64;
		    inSymbol;
		_);
		if (SY = INTCONST) then _(
		    l3var6z := 1000B * curToken.i + l3var6z;
		    if (suffix = noSuffix) and
		       (1 < curToken.i) and
		       (curToken.i < 127) then _(
			l3var6z := l3var6z + 128;
		    _) else if (suffix = suffixB) and
			      (1000000B < curToken.i) and
			      (curToken.i < 1743671743B) then _(
			l3var6z := l3var6z + 256;
		    _) else _(
			error(76); (* errWrongNumberForExternalFile *)
		    _);
		    inSymbol;
		_) else _(
		    l3var6z := 512;
		_);
		curExternFile@.location := l3var6z;
		if (SY = COMMA) then
		    inSymbol;
	    _); (* 22042 *)
	    checkSymAndRead(RPAREN);
	    checkSymAndRead(SEMICOLON);
	    if (outputFile = NIL) then _(
		error(77); (* errNoOutput *)
		outputFile := l3var7z;
	    _);
	    l3var6z := 40;
	    repeat
		programme(l3var6z, programObj);
	    until (SY = PERIOD);
	    if (CH <> 'D') then _(
		int92z := 0;
		int93z := ;
	    _) else _(
		set147z := halfWord;
		dataCheck := false;
		statement;
	    _);
	    readToPos80;
	    curVal.i := l3var6z;
	    symTab[74003B] := (helperNames[25] + [24,27,28,29]) +
				(curVal.m * halfWord);
	_); (* initScalars *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure makeExtFile;
_(
    new(l2var10z);
    with l2var10z@ do _(
	typ := ptr(ord(curExternFile));
	id2 := workidr;
	expr1 := curExpr;
    _);
    curExpr := l2var10z;
_); (* makeExtFile *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure parseParameters;
var
    l3var1z, l3var2z, l3var3z: irptr;
    parClass: idclass;
    l3var5z, l3var6z: integer;
    l3sym7z: symbol;
    noComma: boolean;
    expType: tptr;
_(
    int92z := 0;
    l3var5z := 0;
    int93z := 0;
    inSymbol;
    l3var2z := NIL;
    if not (SY IN [IDENT,VARSY,FUNCSY,PROCSY]) then
        errAndSkip(errBadSymbol, (skipToSet + [IDENT,RPAREN]));
    int92z := 1;
    while (SY IN [IDENT,VARSY,FUNCSY,PROCSY]) do _(
        l3sym7z := SY;
        if (SY = IDENT) then
            parClass := VARID
        else if (SY = VARSY) then
            parClass := FORMALID
        else _(
            parClass := ROUTINEID;
        _);
        l3var3z := NIL;
        if (SY = PROCSY) then
            expType := NIL
        else
            expType := integerType;
        l3var6z := 0;
        if (SY <> IDENT) then _(
            int93z := 0;
            inSymbol;
        _);
        repeat if (SY = IDENT) then _(
            if (isDefined) then
                error(errIdentAlreadyDefined);
            l3var6z := l3var6z + 1;
            new(l3var1z, FORMALID);
            with l3var1z@ do _(
                id := curIdent;
                offset := curFrameRegTemplate;
                cl := parClass;
                next := symHashTabBase[bucket];
                typ := NIL;
                list := curIdRec;
                value := l2int18z;
            _);
            symHashTabBase[bucket] := l3var1z;
            l2int18z := l2int18z + 1;
            if (l3var2z = NIL) then
                curIdRec@.argList := l3var1z
            else
                l3var2z@.list := l3var1z;
            l3var2z := l3var1z;
            if (l3var3z = NIL) then
                l3var3z := l3var1z;
            inSymbol;
        _) else
            errAndSkip(errNoIdent, skipToSet + [RPAREN,COMMA,COLON]);
        noComma := (SY <> COMMA);
        if not noComma then _(
            int93z := 0;
            inSymbol;
        _);
        until noComma;
        if (l3sym7z <> PROCSY) then _(
            checkSymAndRead(COLON);
            parseTypeRef(expType, (skipToSet + [IDENT,RPAREN]));
            if (l3sym7z <> VARSY) then _(
                if (isFileType(expType)) then
                error(5) (*errSimpleTypeReq *)
                else if (expType@.size <> 1) then
                     l3var5z := l3var6z * expType@.size + l3var5z;
            _);
            if (l3var3z <> NIL) then
                while (l3var3z <> curIdRec) do with l3var3z@ do _(
                    typ := expType;
                    l3var3z := list;
                _);
        _);

        if (SY = SEMICOLON) then _(
            int93z := 0;
            inSymbol;
            if not (SY IN (skipToSet + [IDENT,VARSY,FUNCSY,PROCSY])) then
                errAndSkip(errBadSymbol, (skipToSet + [IDENT,RPAREN]));
        _);
    _);
    (* 22276 *)
    if (l3var5z <> 0) then _(
        curIdRec@.flags := (curIdRec@.flags + [23]);
        l3var6z := l2int18z;
        l2int18z := l2int18z + l3var5z;
        l3var2z := curIdRec@.argList;
        (* 22306 *)
        while (l3var2z <> curIdRec) do _(
            if (l3var2z@.cl = VARID) then _(
                l3var5z := l3var2z@.typ@.size;
                if (l3var5z <> 1) then _(
                    l3var2z@.value := l3var6z;
                    l3var6z := l3var6z + l3var5z;
                _)
            _);
            l3var2z := l3var2z@.list;
        _);
    _);
    (* 22322 *)
    checkSymAndRead (RPAREN);
_); (* parseParameters *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure exitScope(var arg: array [0..127] of irptr);
_(
    for ii := 0 to 127 do _(
        workidr := arg[ii];
        while (workidr <> NIL) and
              (workidr >= scopeBound) do
            workidr := workidr@.next;
        arg[ii] := workidr;
    _);
_); (* exitScope *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
_( (* programme *)
    curVarOff := l2arg1z;
    if (curVarOff = 0) then _(
        inSymbol;
        initScalars;
        exit;
    _);
%    writeln(' in programme, level = ', curProcNesting:0);
    preDefHead := ptr(0);
    inTypeDef := false;
    fInitOff := 0;
    strLabList := NIL;
    lineNesting := lineNesting + 1;
    l2var16z := numLabList;
    repeat
    if (SY = LABELSY) then _(
        (*22367*)
        repeat
            inSymbol;
            if (SY <> INTCONST) then _(
                requiredSymErr(INTCONST);
                goto 22421;
            _);
            l2var15z := numLabList;
            while (l2var15z <> l2var16z) do _(
                if (l2var15z@.id <> curToken) then _(
                    l2var15z := l2var15z@.next;
                _) else _(
                    int97z := l2var15z@.line;
                    error(17); (* errLblAlreadyDefinedInLine *)
                    goto 22420;
                _)
            _);
            new(l2var15z);
            with l2var15z@ do _(
                id := curToken;
                frame := curFrameRegTemplate;
                offset := 0;
                line := lineCnt;
                defined := false;
                next := numLabList;
            _);
            numLabList := l2var15z;
22420:      inSymbol;
22421:      if not (SY IN [COMMA,SEMICOLON]) then
                errAndSkip(1, skipToSet + [COMMA,SEMICOLON]);
        until SY <> COMMA;
        if SY = SEMICOLON then
            inSymbol;
    _); (* 22432 *)
    if (SY = CONSTSY) then _(
        parseDecls(0);
        while  (SY = IDENT) do _(
            if (isDefined) then
                error(errIdentAlreadyDefined);
            new(workidr=7);
            workidr@ := [curIdent, curFrameRegTemplate,
                           symHashTabBase[bucket], , ENUMID, NIL];
            symHashTabBase[bucket] := workidr;
            inSymbol;
            if (charClass <> EQOP) then
                error(errBadSymbol)
            else
                inSymbol;
            with workidr@ do
                parseLiteral(typ, high, true);
            if (workidr@.typ = NIL) then _(
                error(errNoConstant);
                workidr@.typ := integerType;
                workidr@.value := 1;
            _) else
                inSymbol;
            if (SY = SEMICOLON) then _(
                int93z := 0;
                inSymbol;
                if not (SY IN (skipToSet + [IDENT])) then _(
                    errAndSkip(errBadSymbol, skipToSet + [IDENT]);
                _)
            _) else _(
                requiredSymErr(SEMICOLON);
            _)
        _)
    _); (* 22511 *)
    objBufIdx := 1;
    if (SY = TYPESY) then _(
        inTypeDef := true;
        typelist := NIL;
        parseDecls(0);
        while SY = IDENT do _(
            if isDefined then
                error(errIdentAlreadyDefined);
            ii := bucket;
            l2var12z := curIdent;
            inSymbol;
            if (charClass <> EQOP) then
                error(errBadSymbol)
            else
                inSymbol;
            parseTypeRef(curType, skipToSet + [SEMICOLON]);
            curIdent := l2var12z;
            if (knownInType(curIdRec)) then _(
                l2typ14z := curIdRec@.typ;
                if (l2typ14z@.base = booleanType) then _(
                    if (curType@.k <> kindPtr) then _(
                        parseDecls(1);
                        error(78); (* errPredefinedAsPointer *)
                    _);
                    l2typ14z@.base := curType@.base;
                _) else _(
                    l2typ14z@.base := curType;
                    curIdRec@.typ := curType;
                _);
                P2672(typelist, curIdRec);
            _) else _(
                new(curIdRec=5);
                with curIdRec@ do _(
                    id := l2var12z;
                    offset := curFrameRegTemplate;
                    typ := curType;
                    cl := TYPEID;
                _)
            _); (* 22574 *)
            curIdRec@.next := symHashTabBase[ii];
            symHashTabBase[ii] := curIdRec;
            int93z := 0;
            checkSymAndRead(SEMICOLON);
        _); (* 22602 *)
        while (typelist <> NIL) do _(
            l2var12z := typelist@.id;
            curIdRec := typelist;
            parseDecls(1);
            error(79); (* errNotFullyDefined *)
            typelist := typelist@.next;
        _)
    _); (* TYPESY -> 22612 *)
    inTypeDef := false;
    curExpr := NIL;
    if (SY = VARSY) then _(
        parseDecls(0);
        (*22617*)
        repeat
            workidr := NIL;
            (*22620*)
            repeat
            if (SY = IDENT) then _(
                new(curIdRec=7);
                if (isDefined) then
                    error(errIdentAlreadyDefined);
                with curIdRec@ do _(
                    id := curIdent;
                    offset := curFrameRegTemplate;
                    next := symHashTabBase[bucket];
                    value := 0c;
                    cl := VARID;
                    list := NIL;
                _);
                symHashTabBase[bucket] := curIdRec;
                inSymbol;
                if (workidr = NIL) then
                    workidr := curIdRec
                else
                    l2var4z@.list := curIdRec;
                l2var4z := curIdRec;
            _) else
                error(errNoIdent);
            if SY = LBRACK then _(
               inSymbol;
               if (SY <> INTCONST) or (curToken.i < 0)
               or (curToken.i > 77777B) then
                  error(errNumberTooLarge);
               curIdRec@.value := curToken.i;
               curIdRec@.offset := 0;
               inSymbol;
               checkSymAndRead(RBRACK);
            _);
            if not (SY IN [COMMA,COLON]) then
                errAndSkip(1, skipToSet + [IDENT,COMMA]);
            l2bool8z := SY <> COMMA;
            if not l2bool8z then _(
                int93z := 0;
                inSymbol;
            _);
            (* 22663 -> 22620 *) until l2bool8z;
            checkSymAndRead(COLON);
            parseTypeRef(curType, skipToSet + [IDENT,SEMICOLON]);
            temp := curType@.size;
            while workidr <> NIL do with workidr@ do _(
                curIdRec := list;
                typ := curType;
                list := NIL;
                l2bool8z := true;
                if (curProcNesting = 1) then _(
                    curExternFile := externFileList;
                    l2var12z := id;
                    curVal.i := temp;
                    toAlloc := curVal.m * halfWord + [24,27,28,29];
                    while l2bool8z and (curExternFile <> NIL) do _(
                        if (curExternFile@.id = l2var12z) then _(
                            l2bool8z := false;
                            if (curExternFile@.line = 0) then _(
                                curVal.i := curExternFile@.offset;
                                workidr@.value := allocExtSymbol(toAlloc);
                                curExternFile@.line := lineCnt;
                            _)
                        _) else _(
                            curExternFile := curExternFile@.next;
                        _)
                    _)
                _); (* 22731 *)
                if (l2bool8z and (workidr@.value = 0c)) then _(
                    workidr@.value := curVarOff;
                    if (PASINFOR.listMode = 3) then _(
                        write('VARIABLE ':25);
                        printTextWord(workidr@.id);
                        writeln(' OFFSET (', curProcNesting:0, ') ',
                                curVarOff:5 oct, 'B. WORDS=',
                                temp:5 oct, 'B');
                    _);
                    curVarOff := curVarOff + temp;
                    curExternFile := NIL;
                _); (*22764*)
                if isFileType(curType) then
                    makeExtFile;
                workidr := curIdRec;
            _); (* 22771 *)
            int93z := 0;
            checkSymAndRead(SEMICOLON);
            if (SY <> IDENT) and not (SY IN skipToSet) then
                errAndSkip(errBadSymbol, skipToSet + [IDENT]);
        (* 23001 -> 22617 *) until SY <> IDENT;
    _); (* VARSY -> 23003 *)
    if (curProcNesting = 1) then _(
        workidr := outputFile;
        curExternFile := fileForOutput;
        makeExtFile;
        if (inputFile <> NIL) then _(
            workidr := inputFile;
            curExternFile := fileForInput;
            makeExtFile;
        _)
    _);

%    writeln(' formfileinit called, curexpr = ', curexpr:5 oct,
%    ' level = ', curProcNesting:0);

    if  (curExpr <> NIL) and not (S5 in optSflags.m) then _(
        fInitOff := moduleOffset;
        formOperator(gen14);
    _) else
        fInitOff := 0;
    if (curProcNesting = 1) then _(
        curExternFile := externFileList;
        while (curExternFile <> NIL) do _(
            if (curExternFile@.line = 0) then _(
                error(80); (* errUndefinedExternFile *)
                printTextWord(curExternFile@.id);
                writeLN;
            _);
            curExternFile := curExternFile@.next;
        _)
    _); (*23035*)
    outputObjFile;
    while (SY = PROCSY) or (SY = FUNCSY) do _(
        l2bool8z := SY = PROCSY;
        if (curFrameRegTemplate = 7) then _(
            error(81); (* errProcNestingTooDeep *)
        _);
        int93z := 0;
        inSymbol;
        if (SY <> IDENT) then _(
            error(errNoIdent);
            curIdRec := uProcPtr;
            isPredefined := false;
        _) else _(
            if (isDefined) then with hashTravPtr@ do _(
                if (cl = ROUTINEID) and
                   (list = NIL) and
                   (preDefLink <> NIL) and
                   ((typ = NIL) = l2bool8z) then _(
                    isPredefined := true;
                _) else _(
                    isPredefined := false;
                    error(errIdentAlreadyDefined);
                    printErrMsg(82); (* errPrevDeclWasNotForward *)
                _);
            _) else
                isPredefined := false;
        _); (* 23103 *)
        if not isPredefined then _(
            new(curIdRec, 12);
            with curIdRec@ do _(
                id := curIdent;
                offset := curFrameRegTemplate;
                next := symHashTabBase[bucket];
                typ := NIL;
                symHashTabBase[bucket] := curIdRec;
                cl := ROUTINEID;
                list := NIL;
                value := 0;
                argList := NIL;
                preDefLink := NIL;
                if (declExternal) then
                    flags := [0:15,22]
                else
                    flags := [0:15];
                pos := 0;
                curFrameRegTemplate := curFrameRegTemplate + frameRegTemplate;
                if l2bool8z then
                    l2int18z := 3
                else
                    l2int18z := 4;
            _);
            curProcNesting := curProcNesting + 1;
            inSymbol;
            if (6 < curProcNesting) then
                error(81); (* errProcNestingTooDeep *)
            if not (SY IN [LPAREN,SEMICOLON,COLON]) then
                errAndSkip(errBadSymbol, skipToSet + [LPAREN,SEMICOLON,COLON]);
            if (SY = LPAREN) then
                parseParameters;
            if not l2bool8z then _(
                if (SY <> COLON) then
                    errAndSkip(106 (*:*), skipToSet + [SEMICOLON])
                else _(
                    inSymbol;
                    parseTypeRef(curIdRec@.typ, skipToSet + [SEMICOLON]);
                    if (curIdRec@.typ@.size <> 1) then
                        error(errTypeMustNotBeFile);
                _)
            _);
        _) else (*23167*) _(
            with hashTravPtr@ do _(
                l2int18z := level;
                curFrameRegTemplate := curFrameRegTemplate + indexreg[1];
                curProcNesting := curProcNesting + 1;
                if (preDefHead = hashTravPtr) then _(
                    preDefHead := preDefLink;
                _) else _(
                    curIdRec := preDefHead;
                    while (hashTravPtr <> curIdRec) do _(
                        workidr := curIdRec;
                        curIdRec := curIdRec@.preDefLink;
                    _);
                    workidr@.preDefLink := hashTravPtr@.preDefLink;
                _)
            _);
            hashTravPtr@.preDefLink := NIL;
            curIdRec := hashTravPtr@.argList;
            if (curIdRec <> NIL) then _(
                while (curIdRec <> hashTravPtr) do _(
                    addToHashTab(curIdRec);
                    curIdRec := curIdRec@.list;
                _)
            _);
            curIdRec := hashTravPtr;
            setup(scopeBound);
            inSymbol;
        _); (* 23224 *)
        checkSymAndRead(SEMICOLON);
        with curIdRec@ do if (curIdent = litForward) then _(
            if (isPredefined) then
                error(83); (* errRepeatedPredefinition *)
            level := l2int18z;
            preDefLink := preDefHead;
            preDefHead := curIdRec;
        _) else (* 23237 *) if (curIdent = litExternal) or
            (curIdent = litFortran) or (curIdent = litOct) then _(
            if (curIdent = litExternal) then _(
                curVal.m := [20];
            _) else if (checkFortran) then _(
                curVal.m := [21,24];
                checkFortran := false;
            _) _else if (curIdent = litOct) then _(
                curVal.m := [24];
            _) else _(
                curVal.m := [21];
            _);
            curIdRec@.flags := curIdRec@.flags + curVal.m;
        _) else (* 23257 *) _(
            repeat
                setup(scopeBound);
                programme(l2int18z, curIdRec);
                if not (SY IN [FUNCSY,PROCSY,BEGINSY]) then
                    errAndSkip(errBadSymbol, skipToSet);
            until SY IN [FUNCSY,PROCSY,BEGINSY];
            rollup(scopeBound);
            exitScope(symHashTabBase);
            exitScope(typeHashTabBase);
            goto 23301;
        _); (* 23277 *)
        inSymbol;
        checkSymAndRead(SEMICOLON);
23301:  workidr := curIdRec@.argList;
        if (workidr <> NIL) then _(
            while (workidr <> curIdRec) do _(
                scopeBound := NIL;
                P2672(scopeBound, workidr);
                workidr := workidr@.list;
            _)
        _); (* 23314 *)
        curFrameRegTemplate := curFrameRegTemplate - indexreg[1];
        curProcNesting := curProcNesting - 1;
    _); (* 23320 *)

    if (SY <> BEGINSY) and
       (not allowCompat or not (SY IN blockBegSys)) then
        errAndSkip(84 (* errErrorInDeclarations *), skipToSet);
%        writeln(' here with ', SY, ' line ', lineCnt:0);
    until SY in statBegSys;
    if (preDefHead <> ptr(0)) then _(
        error(85); (* errNotFullyDefinedProcedures *)
        while (preDefHead <> ptr(0)) do _(
            printTextWord(preDefHead@.id);
            preDefHead := preDefHead@.preDefLink;
        _);
        writeLN;
    _);
    defineRoutine;
    while (numLabList <> l2var16z) do _(
        if not (numLabList@.defined) then _(
            write(' ', numLabList@.id.i:0, ':');
            l2bool8z := false;
        _);
        numLabList := numLabList@.next;
    _);
    if not l2bool8z then _(
        printTextWord(procPtr@.id);
        error(90); (* errLblDefinitionInBlock *)
    _);
    l2arg1z := l2int21z;
    (* 23364 *)
_); (* programme *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure initTables;
var
    idx, jdx: integer;
    l2unu3z, l2unu4z, l2unu5z: word;
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure initInsnTemplates;
var
    i: insn;
    op: operator;
_(
    for i := ATX to JADDM do
        insnTemp[i] := ord(i) * 10000B;
    insnTemp[ELFUN] := 500000B;
    jdx := KUTC;
    for i := UTC to VJM do _(
        insnTemp[i] := jdx;
        jdx := (jdx + 100000B);
    _);
    for idx to 15 do
        indexreg[idx] := idx * frameRegTemplate;
    jumpType := insnTemp[UJ];
    for op := MUL to ASSIGNOP do _(
        opFlags[op] := opfCOMM;
        opToInsn[op] := 0;
        if (op IN [MUL, RDIVOP, PLUSOP, MINUSOP]) then _(
            opToMode[op] := 3;
        _) else if (op IN [IDIVOP, IMODOP]) then _(
            opToMode[op] := 2;
        _) else if (op IN [IMULOP, INTPLUS, INTMINUS, badop27]) then _(
            opToMode[op] := 1;
        _) else if (op IN [IDIVROP,badop30,badop31]) then _(
            opToMode[op] := 4;
        _) else _(
            opToMode[op] := 0;
        _)
    _);
    opToInsn[MUL] := insnTemp[AMULX];
    opToInsn[RDIVOP] := insnTemp[ADIVX];
    opToInsn[IDIVOP] := 17; (* P/DI *)
    opToInsn[IMODOP] := 11; (* P/MD *)
    opToInsn[PLUSOP] := insnTemp[ADD];
    opToInsn[MINUSOP] := insnTemp[SUB];
    opToInsn[IMULOP] := insnTemp[AMULX];
    opToInsn[SETAND] := insnTemp[AAX];
    opToInsn[SETXOR] := insnTemp[AEX];
    opToInsn[SETOR] := insnTemp[AOX];
    opToInsn[INTPLUS] := insnTemp[ADD];
    opToInsn[INTMINUS] := insnTemp[SUB];
    opToInsn[IDIVROP] := 67; (* P/IS *)
    opToInsn[badop27] := 22; (* P/II unused, undefined *)
    opToInsn[badop30] := 23; (* P/RR *)
    opToInsn[badop31] := 24; (* P/RI *)
    opToInsn[MKRANGE] := 61; (* P/PI *)
    opToInsn[SETSUB] := insnTemp[AAX];
    opFlags[AMPERS] := opfAND;
    opFlags[IDIVOP] := opfDIV;
    opFlags[OROP] := opfOR;
    opFlags[IMULOP] := opfMULMSK;
    opFlags[IMODOP] := opfMOD;
    opFlags[badop27] := opfHELP;
    opFlags[badop30] := opfHELP;
    opFlags[badop31] := opfHELP;
    opFlags[MKRANGE] := opfHELP;
    opFlags[IDIVROP] := opfHELP;
    opFlags[ASSIGNOP] := opfASSN;
    opFlags[SETSUB] := opfINV;
    for jdx := 0 to 6 do _(
        funcInsn[jdx] := (500000B + jdx);
    _)
(* 23516 *)_); (* initInsnTemplates *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure regKeywords;
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure regResWord(l4arg1z: integer);
var
    kw: @kword;
    l4var2z: word;
_(
    curVal.i := l4arg1z;
    curVal.m := curVal.m * hashMask.m;
    mapai(curVal.a, curVal.i);
    l4var2z.i := l4arg1z;
    new(kw);
    with kw@ do _(
        w := l4var2z;
        sym := SY;
        op := charClass;
        next := kwordHashTabBase[curVal.i];
    _);
    kwordHashTabBase[curVal.i] := kw;
    if (charClass = NOOP) then _(
        SY := succ(SY);
    _) else _(
        charClass := succ(charClass);
    _)
_); (* regResWord *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
_( (* regKeywords *)
    SY := MULOP;
    charClass := AMPERS;
    regResWord(415644C(*"     AND"*));
    regResWord(445166C(*"     DIV"*));
    regResWord(555744C(*"     MOD"*));
    SY := GTSY; (* reused as NILSY *)
    charClass := NOOP;
    regResWord(565154C(*"     NIL"*));
    SY := ADDOP;
    charClass := OROP;
    regResWord(5762C(*"      OR"*));
    SY := RELOP;
    charClass := INOP;
    regResWord(5156C(*"      IN"*));
    SY := NOTSY;
    charClass := NOOP;
    regResWord(565764C(*"     NOT"*));
    SY := LABELSY;
    charClass := NOOP;
    for idx := 0 to 29 do
        regResWord(resWordNameBase[idx]);
_); (* regKeywords *)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure initArrays;
var
    l3var1z, l3var2z: word;
_(
    FcstCnt := 0;
    FcstBottom := 0;
    FcstTop := 501;
    for idx := 3 to 6 do _(
        l3var2z.i := (idx - (2));
        for jdx to l3var2z.i do
            frameRestore[idx][jdx] := 0;
    _);
    for idx to 99 do
        helperMap[idx] := 0;
_); (* initArrays *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure initSets;
_(
    skipToSet := blockBegSys + statBegSys - [CASESY];
    bigSkipSet := skipToSet + statEndSys;
_); (* initSets *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
_( (* initTables *)
    initArrays;
    initInsnTemplates;
    initSets;
    unpack(pasinfor.a3@, iso2text, '_052'); (* '*' *)
    rewrite(CHILD);
    for jdx to 10 do
        put(CHILD);
    for idx := 0 to 127 do _(
        symHashTabBase[idx] := NIL;
        typeHashTabBase[idx] := ;
        kwordHashTabBase[idx] := ;
    _);
    regKeywords;
    numLabList := NIL;
    totalErrors := 0;
    heapCallsCnt := 0;
    putLeft := true;
    fetch := true;
    curFrameRegTemplate := frameRegTemplate;
    curProcNesting := 1;
_); (* initTables *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure finalize;
var
    idx, cnt, unused: integer;
    sizes: array [1..10] of @integer;
_(
    sizes[1] := ptr(1);
    sizes[2] := ptr(symTabPos - 74000B - 1);
    sizes[5] := ptr(longSymCnt);
    sizes[6] := ptr(moduleOffset - 40000B);
    sizes[8] := ptr(FcstCnt);
    sizes[3] := ptr(0);
    sizes[4] := ;
    sizes[7] := ;
    sizes[9] := ptr(int92z);
    sizes[10] := ptr(int93z);
    curVal.i := moduleOffset - 40000B;
    symTab[74001B] := [24,29] + curVal.m - intZero;
    reset(FCST);
    while not eof(FCST) do _(
        write(CHILD, FCST@);
        get(FCST);
    _);
    curVal.i := (symTabPos - 70000B) * 100000000B;
    for cnt to longSymCnt do _(
        idx := longSymTabBase[cnt];
        symTab[idx] := (symTab[idx] + (curVal.m * [9:23]));
        curVal.i := (curVal.i + 100000000B);
    _);
    symTabPos := (symTabPos - (1));
    for cnt := 74000B to symTabPos do
        write(CHILD, symTab[cnt]);
    for cnt to longSymCnt do
        write(CHILD, longSyms[cnt]);
    if (allowCompat) then _(
        write((lineCnt - 1):6, ' LINES STRUCTURE ');
        for idx to 10 do
            write(ord(sizes[idx]):0, ' ');
        writeln;
    _);
    entryPtTable[entryPtCnt] := [];
    pasinfor.entryptr@ := entryPtTable;
    pasinfor.sizes := sizes;
_); (* finalize *)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
procedure initOptions;
_(
    pasinfor.startOffset := pasinfor.startOffset - 16384;
    commentModeCH := ' ';
    lineNesting := 0;
    maxLineLen := 72;
    CH := ' ';
    linePos := 0;
    prevErrPos := 0;
    errsInLine := 0;
    lineCnt := 1;
    checkFortran := false;
    bool110z := false;
    int93z := 1;
    int92z := 1;
    moduleOffset := 16384;
    lineStartOffset := ;
    int94z := 1;
    bool47z := false;
    dataCheck := ;
    heapSize := 100;
    bool49z := true;
    atEOL := false;
    curVal.m := pasinfor.flags;
    besm(ASN64 - 39);
    besm(ASN64 + 45);
    optSflags := ;
    doPMD := not (42 in curVal.m);
    checkTypes := true;
    fixMult := true;
    fuzzReals := true;
    pseudoZ := ;
    checkBounds := not (44 in curVal.m);
    declExternal := false;
    errors := false;
    allowCompat := false;
    litExternal.i := 4570644562564154C;
    litForward.i := 46576267416244C;
    litFortran.i := 46576264624156C;
    fileBufSize := 1;
    charEncoding := 2;
    chain := NIL;
    litOct.i := 574364C;
    longSymCnt := 0;
    pasinfor.errors@ := true;
    extSymAdornment := 0;
    symTabCnt := 0;
_); (* initOptions *)
%
_( (* main *)
    if PASINFOR.listMode <> 0 then
        writeln(boilerplate);
    initOptions;
    curInsnTemplate := 0;
    initTables;
    programme(curInsnTemplate, hashTravPtr);
    if errors then _(
9999:   writeln(' IN ', (lineCnt-1):0, ' LINES ',
            totalErrors:0, ' ERRORS');
    _) else _(
        finalize;
        PASINFOR.errors@ := false;
    _)
_)
.data
    frameRegTemplate := 04000000B;
    constRegTemplate := I8;
    disNormTemplate :=  KNTR+7;
    blockBegSys := [LABELSY, CONSTSY, TYPESY, VARSY, FUNCSY, PROCSY, BEGINSY];
    statBegSys :=  [BEGINSY, IFSY, CASESY, REPEATSY, WHILESY, FORSY, WITHSY,
                    GOTOSY, SELECTSY];
    O77777 := [33:47];
    intZero := 0;
    unused138z := (63000000C);
    extSymMask := (43000000C);
    halfWord := [24:47];
    hashMask := 203407C;
    statEndSys := [SEMICOLON, ENDSY, ELSESY, UNTILSY];
    lvalOpSet := [GETELT, GETVAR, op36, op37, GETFIELD, DEREF, FILEPTR];
    resWordNameBase :=
        5441424554C             (*"   LABEL"*),
        4357566364C             (*"   CONST"*),
        64716045C               (*"    TYPE"*),
        664162C                 (*"     VAR"*),
        4665564364515756C       (*"FUNCTION"*),
        6062574345446562C       (*"PROCEDUR"*),
        634564C                 (*"     SET"*),
        604143534544C           (*"  PACKED"*),
        4162624171C             (*"   ARRAY"*),
        624543576244C           (*"  RECORD"*),
        46515445C               (*"    FILE"*),
        4245475156C             (*"   BEGIN"*),
        5146C                   (*"      IF"*),
        43416345C               (*"    CASE"*),
        624560454164C           (*"  REPEAT"*),
        6750515445C             (*"   WHILE"*),
        465762C                 (*"     FOR"*),
        67516450C               (*"    WITH"*),
        47576457C               (*"    GOTO"*),
        455644C                 (*"     END"*),
        45546345C               (*"    ELSE"*),
        6556645154C             (*"   UNTIL"*),
        5746C                   (*"      OF"*),
        4457C                   (*"      DO"*),
        6457C                   (*"      TO"*),
        445767566457C           (*"  DOWNTO"*),
        64504556C               (*"    THEN"*),
        634554454364C           (*"  SELECT"*),
        60625747624155C         (*" PROGRAM"*),
        576450456263C           (*"  OTHERS"*);
%
    charSymTabBase := NOSY:128;
    chrClassTabBase := NOOP:128;
    charSymTabBase['0'] := INTCONST:10;
    chrClassTabBase['0'] := ALNUM:10;
    charSymTabBase['A'] := IDENT:26;
    chrClassTabBase['A'] := ALNUM:26;
    charSymTabBase['ะฎ'] := IDENT:31;
    chrClassTabBase['ะฎ'] := ALNUM:31;
    funcInsn[fnABSR] := KAMX;
    funcInsn[fnTRUNC] := KADD+ZERO;
    funcInsn[fnODD] := KAAX+E1;
    funcInsn[fnORD] := KAOX+ZERO;
    funcInsn[fnCHR] := KAAX+MANTISSA;
    funcInsn[fnSUCC] := KARX+E1;
    funcInsn[fnPRED] := KSUB+E1;
    funcInsn[fnSQRR] := macro + mcSQRR;
    funcInsn[fnROUND] := macro + mcROUND;
    funcInsn[fnCARD] := macro + mcCARD;
    funcInsn[fnMINEL] := macro + mcMINEL;
    funcInsn[fnPTR] := KAAX+MANTISSA;
    funcInsn[fnABSI] := KAMX;
    funcInsn[fnSQRI] := macro + mcSQRI;
    funcInsn[fnSHIFT] := macro + mcSHIFT;
    iAddOpMap[PLUSOP] := INTPLUS, INTMINUS;
    setOpMap[PLUSOP] := SETOR, SETSUB;
    imulOpMap := IMULOP, IDIVROP;
    setOpMap[MUL] := SETAND, SETXOR;
    charSymTabBase[chr(27)] := CHARCONST;
    charSymTabBase[''''] := CHARCONST;
    charSymTabBase['_'] := REALCONST;
    charSymTabBase['<'] := LTSY;
    charSymTabBase['>'] := GTSY;
    chrClassTabBase['+'] := PLUSOP;
    chrClassTabBase['-'] := MINUSOP;
    chrClassTabBase['*'] := MUL;
    chrClassTabBase['/'] := RDIVOP;
    chrClassTabBase['='] := EQOP;
    chrClassTabBase['&'] := AMPERS;
    chrClassTabBase['รท'] := IDIVOP;
    chrClassTabBase['โจ'] := OROP;
    chrClassTabBase['>'] := GTOP;
    chrClassTabBase['<'] := LTOP;
    chrClassTabBase['#'] := NEOP;
    chrClassTabBase['='] := EQOP;
    chrClassTabBase['ร'] := MUL;
    chrClassTabBase['โค'] := LEOP;
    chrClassTabBase['โฅ'] := GEOP;
    charSymTabBase['โค'] := RELOP;
    charSymTabBase['โฅ'] := RELOP;
    charSymTabBase['+'] := ADDOP;
    charSymTabBase['-'] := ADDOP;
    charSymTabBase['โจ'] := ADDOP;
    charSymTabBase['*'] := MULOP;
    charSymTabBase['/'] := MULOP;
    charSymTabBase['&'] := MULOP;
    charSymTabBase['ร'] := MULOP;
    charSymTabBase[','] := COMMA;
    charSymTabBase['.'] := PERIOD;
    charSymTabBase[chr(22)] := ARROW;
    charSymTabBase['@'] := ARROW;
    charSymTabBase['^'] := ARROW;
    charSymTabBase['('] := LPAREN;
    charSymTabBase[')'] := RPAREN;
    charSymTabBase[';'] := SEMICOLON;
    charSymTabBase['['] := LBRACK;
    charSymTabBase[']'] := RBRACK;
    charSymTabBase['#'] := RELOP;
    charSymTabBase['='] := RELOP;
    charSymTabBase[':'] := COLON;
    charSymTabBase['รท'] := MULOP;
    charSymTabBase['~'] := NOTSY;
    helperNames :=
        6017210000000000C      (*"P/1     "*),
        6017220000000000C      (*"P/2     "*),
        6017230000000000C      (*"P/3     "*),
        6017240000000000C      (*"P/4     "*),
        6017250000000000C      (*"P/5     "*),
        6017260000000000C      (*"P/6     "*),
        6017434100000000C      (*"P/CA    "*),
        6017455700000000C      (*"P/EO    "*),
        6017636300000000C      (*"P/SS    "*),
(*10*)  6017455400000000C      (*"P/EL    "*),
        6017554400000000C      (*"P/MD    "*),
        6017555100000000C      (*"P/MI    "*),
        6017604100000000C      (*"P/PA    "*),
        6017655600000000C      (*"P/UN    "*),
        6017436000000000C      (*"P/CP    "*),
        6017414200000000C      (*"P/AB    "*),
        6017445100000000C      (*"P/DI    "*),
        6017624300000000C      (*"P/RC    "*),
        6017454100000000C      (*"P/EA    "*),
(*20*)  6017564100000000C      (*"P/NA    "*),
        6017424100000000C      (*"P/BA    "*),
        6017515100000000C      (*"P/II   u"*),
        6017626200000000C      (*"P/RR    "*),
        6017625100000000C      (*"P/RI    "*),
        6017214400000000C      (*"P/1D    "*),
        6017474400000000C      (*"P/GD    "*),
        6017450000000000C      (*"P/E     "*),
        6017454600000000C      (*"P/EF    "*),
        6017604600000000C      (*"P/PF    "*),
(*30*)  6017474600000000C      (*"P/GF    "*),
        6017644600000000C      (*"P/TF    "*),
        6017624600000000C      (*"P/RF    "*),
        6017566700000000C      (*"P/NW    "*),
        6017446300000000C      (*"P/DS    "*),
        6017506400000000C      (*"P/HT    "*),
        6017675100000000C      (*"P/WI    "*),
        6017676200000000C      (*"P/WR    "*),
        6017674300000000C      (*"P/WC    "*),
        6017412600000000C      (*"P/A6    "*),
(*40*)  6017412700000000C      (*"P/A7    "*),
        6017677000000000C      (*"P/WX    "*),
        6017675700000000C      (*"P/WO    "*),
        6017436700000000C      (*"P/CW    "*),
        6017264100000000C      (*"P/6A    "*),
        6017274100000000C      (*"P/7A    "*),
        6017675400000000C      (*"P/WL    "*),
        6017624451000000C      (*"P/RDI   "*),
        6017624462000000C      (*"P/RDR   "*),
        6017624443000000C      (*"P/RDC   "*),
(*50*)  6017624126000000C      (*"P/RA6   "*),
        6017624127000000C      (*"P/RA7   "*),
        6017627000000000C      (*"P/RX   u"*),
        6017625400000000C      (*"P/RL    "*),
        6017675754560000C      (*"P/WOLN  "*),
        6017625154560000C      (*"P/RILN  "*),
        6017626200000000C      (*"P/RR    "*),
        6017434500000000C      (*"P/CE    "*),
        6017646200000000C      (*"P/TR    "*),
        6017546600000000C      (*"P/LV    "*),
(*60*)  6017724155000000C      (*"P/ZAM  u"*),
        6017605100000000C      (*"P/PI    "*),
        6017426000000000C      (*"P/BP    "*),
        6017422600000000C      (*"P/B6    "*),
        6017604200000000C      (*"P/PB    "*),
        6017422700000000C      (*"P/B7    "*),
        6017515600000000C      (*"P/IN    "*),
        6017516300000000C      (*"P/IS    "*),
        6017444100000000C      (*"P/DA    "*),
        6017435700000000C      (*"P/CO    "*),
(*70*)  6017516400000000C      (*"P/IT    "*),
        6017435300000000C      (*"P/CK    "*),
        6017534300000000C      (*"P/KC    "*),
        6017545647604162C      (*"P/LNGPAR"*),
        6017544441620000C      (*"P/LDAR  "*),
        6017544441625156C      (*"P/LDARIN"*),
        6017202043000000C      (*"P/00C   "*),
        6017636441620000C      (*"P/STAR  "*),
        6017605544634564C      (*"P/PMDSET"*),
        6017435100000000C      (*"P/CI    "*),
(*80*)  6041514200000000C      (*"PAIB    "*),
        6017674100000000C      (*"P/WA    "*),
        6361626412000000C      (*"SQRT*   "*),
        6351561200000000C      (*"SIN*    "*),
        4357631200000000C      (*"COS*    "*),
        4162436441561200C      (*"ARCTAN* "*),
        4162436351561200C      (*"ARCSIN* "*),
        5456120000000000C      (*"LN*     "*),
        4570601200000000C      (*"EXP*    "*),
        6017456100000000C      (*"P/EQ    "*),
(*90*)  6017624100000000C      (*"P/RA    "*),
        6017474500000000C      (*"P/GE    "*),
        6017554600000000C      (*"P/MF    "*),
        6017465500000000C      (*"P/FM    "*),
        6017565600000000C      (*"P/NN    "*),
        6017634300000000C      (*"P/SC    "*),
        6017444400000000C      (*"P/DD    "*),
        6017624500000000C      (*"P/RE    "*);
    systemProcNames :=
(*0*)   606564C                (*"     PUT"*),
        474564C                (*"     GET"*),
        62456762516445C        (*" REWRITE"*),
        6245634564C            (*"   RESET"*),
        564567C                (*"     NEW"*),
        44516360576345C        (*" DISPOSE"*),
        50415464C              (*"    HALT"*),
        63645760C              (*"    STOP"*),
        6345646560C            (*"   SETUP"*),
        625754546560C          (*"  ROLLUP"*),
(*10*)  6762516445C            (*"   WRITE"*),
        67625164455456C        (*" WRITELN"*),
        62454144C              (*"    READ"*),
        624541445456C          (*"  READLN"*),
        45705164C              (*"    EXIT"*),
        4445426547C            (*"   DEBUG"*),
        42456355C              (*"    BESM"*),
        5541605141C            (*"   MAPIA"*),
        5541604151C            (*"   MAPAI"*),
        604353C                (*"     PCK"*),
(*20*)  6556604353C            (*"   UNPCK"*),
        60414353C              (*"    PACK"*),
        655660414353C          (*"  UNPACK"*),
        5760455644C            (*"   OPEND"*),
        44455444C              (*"    DELD"*),
        56456744C              (*"    NEWD"*),
        60656444C              (*"    PUTD"*),
        47456444C              (*"    GETD"*),
        55574444C              (*"    MODD"*),
        64645157C              (*"    TTIO"*);
end
*table:exclude(program)
*exclude
*table:liblist(*pascom,pasmitxt)
*liblist:660000
*assem
          PASISOCD:,NAME,DTRAN  /01.06.84/
          ISOPGOST:,LC,22
          ISOPTEXT:,LC,11
          ISOPITM:,LC,22
          ISOPRESV:,LC,22
          13,UJ,
          ,DATA,
          /0001B:,TEXT,8H*+ - /01
          ,TEXT,8H23456789
          ,TEXT,8H       A
          ,TEXT,8HBCDEFGHI
          ,TEXT,8HJKLMNOPQ
          ,TEXT,8HRSTUVWXY
          ,TEXT,8HZ     ะฎA
          ,TEXT,8HะะฆะEะคะXะ
          ,TEXT,8HะKะMHOะะฏ
          ,TEXT,8HPCTYะBะฌะซ
          ,TEXT,8Hะะจะญะฉะง
          ,TEXT,8H
          /0015B:,GOST,6H     โฒ135โฒ
          ,GOST,6Hโฒ24โฒ
          ,GOST,6H  โฒ116โฒโฒ117โฒโฒ32โฒ
          ,GOST,6H   โฒ131โฒโฒ21โฒโฒ20โฒ
          ,GOST,6Hโฒ34โฒโฒ136โฒโฒ124โฒโฒ173โฒโฒ122โฒโฒ125โฒ
          ,GOST,6Hโฒ120โฒโฒ123โฒ โฒ133โฒโฒ134โฒ
          ,GOST,6Hโ%โฒ121โฒโฒ137โฒ()
          ,GOST,18H*+,-./0123456789:;
          ,GOST,6H<=>โฒ133โฒโฒ21โฒA
          ,GOST,24HBCDEFGHIJKLMNOPQRSTUVWXY
          ,GOST,6HZ[ ]โฒ115โฒโฒ132โฒ
          ,GOST,24HะฎAะะฆะEะคะXะะKะMHOะะฏPCTYะB
          ,GOST,18Hะฌะซะะจะญะฉะง
          ,LOG,360 7417 0360 7417
 koi8:,iso,6H'0''1''2''3''4''5'
 ,iso,6H'6''7''10''11''12''13'
 ,iso,6H'14''15''16''17''20''21'
 ,iso,6H'22''23''24''25''26''27'
 ,iso,6H'30''31''32''33''34''35'
 ,iso,6H'36''37''40''41''42''43'
 ,iso,6H'44''45''46''47''50''51'
 ,iso,6H'52''53''54''55''56''57'
 ,iso,6H'60''61''62''63''64''65'
 ,iso,6H'66''67''70''71''72''73'
 ,iso,6H'74''75''76''77''100'A
 ,iso,24HBCDEFGHIJKLMNOPQRSTUVWXY
 ,iso,6HZ['134']^_
 ,iso,6H'340'A'342''343''344'E
 ,iso,6H'346''347'X'351''352'K
 ,iso,6H'354'MHO'360''361'
 ,iso,6HPCT'365''366'B
 ,iso,18H'370''371''372''373''374''375''376'
          11,SET,/0001B
          1,,ISOPTEXT
          22,SET,/0015B
          1,,ISOPGOST
          22,SET,koi8
          1,,ISOPRESV
          ,END,
 newpasc:,name,
 *pascom:,subp,
 ,end,
*libra:2
*call overlay*:670000
 monitor*(newpasc)
*end record
*      to perso:670000
*call ocatalog:670000
*system
*trans:newpasc,,670000
(*=y+,l3*)program foo(output); var a [12345b] : integer;
_(
writeln(integer([0,1,3,46,47])*integer([0,1,3,45,47]))
_).
*no lo
*execute
*end file
``````
ะะะะะะฆ
%writeln('Hello from the underworld!')
